# Progress Log - direct-nlopt-rs: NLOPT DIRECT algorithm family in Rust


## Iteration 0 — Project Setup & Ralph Initialization (2026-02-21)

### What was implemented
- Initialized git repository in `direct-nlopt-rs/` with basic Rust project structure
- Created feature branch `feature/nlopt-direct-faithful-implementation` for all ralph-driven changes
- Created Cargo.toml with dependencies: rayon, parking_lot, thiserror, ordered-float, libc, etc.
- Created src/lib.rs crate root with module declarations
- Created src/error.rs with DirectReturnCode and DirectError types matching NLOPT's direct_return_code enum
- Created benches/benchmarks.rs placeholder for Criterion benchmarks
- Created .gitignore
- Thoroughly analyzed both NLOPT DIRECT implementations:
  - Gablonsky Fortran→C translation (DIRect.c, DIRsubrout.c, DIRserial.c, direct_wrap.c): ~2600 lines
  - SGJ C re-implementation (cdirect.c, hybrid.c): ~950 lines
- Generated permanent context prompt (prompts/direct-nlopt-rs.txt) with full project context,
  NLOPT C → Rust function mapping tables for both implementations, data structure correspondence,
  algorithm flow documentation, parallelization strategy, and task instructions
- Generated PRD plan (plans/prd-direct-nlopt.json) with 54 ordered tasks across 12 categories:
  analysis (5), implementation (10), test-foundation (1), test-unit (7), test-integration (11),
  parallelization (4), performance (3), ffi (1), edge-cases (3), test-regression (3), documentation (2)
- Verified Rust project builds successfully

### Files created
- direct-nlopt-rs/.gitignore
- direct-nlopt-rs/Cargo.toml
- direct-nlopt-rs/src/lib.rs
- direct-nlopt-rs/src/error.rs
- direct-nlopt-rs/benches/benchmarks.rs
- prompts/direct-nlopt-rs.txt (permanent context prompt for ralph)
- plans/prd-direct-nlopt.json (54-item PRD plan)

### Git commits
- `df12538` chore(init): initialize direct-nlopt-rs project with basic structure

### Test results
- Project builds successfully (cargo build)
- No tests yet (baseline)

### Notes
- Two NLOPT DIRECT codepaths must be ported: Gablonsky translation AND SGJ re-implementation
- The Gablonsky translation uses SoA + linked lists (similar to scipy port in direct-rs/)
- The SGJ re-implementation uses red-black trees (cleaner but different data structure)
- Both codepaths must produce identical results to their NLOPT C counterparts
- Parallelization via rayon should be added at function evaluation points
- The venv/ folder has Python 3.12 for any comparison scripts needed


## Iteration 1 — Analysis of DIRect.c Main Loop and Memory Layout (2026-02-21)

### What was implemented
- Thoroughly analyzed `nlopt/src/algs/direct/DIRect.c` line by line, documenting:
  - Complete `direct_direct_()` function: signature, all parameters, return codes
  - Full variable map: every dynamically allocated array (`c__`, `f`, `length`, `point`,
    `anchor`, `s`, `thirds`, `levels`, `w`, `oldl`, `oldu`, `list2`, `arrayi`) with sizes,
    indexing conventions (1-based Fortran heritage), and purpose
  - All scalar variables: `jones`, `ifree`, `minpos`, `fmax`, `numfunc`, `actdeep`,
    `actmaxdeep`, `maxi`, `maxpos`, `ifeasiblef`, `iinfesiblef`, `iepschange`, etc.
  - Memory allocation scheme: `MAXFUNC = maxf + 1000 + maxf/2`, `MAXDEEP = MAXFUNC/5`,
    `MAXDIV = 5000` constant
  - SGJ's transposition of arrays from Fortran column-major to C row-major layout
  - Initialization sequence: `dirheader_()` → `dirinitlist_()` → `dirpreprc_()` → `dirinit_()`
  - Main iteration loop: `dirchoose_()` → `dirdoubleinsert_()` (Original only) →
    for-each-selected-rect: remove → `dirget_i_()` → `dirsamplepoints_()` →
    `dirsamplef_()` → `dirdivide_()` → `dirinsertlist_()`
  - Termination checks in exact order: volume_tol → sigma_tol → fglobal → replace_inf →
    epsilon update → budget increase → maxfeval
  - Epsilon update logic: fixed when eps>0 (`iepschange=0`), Jones formula when eps<0
    (`iepschange=1`, `eps = max(|minf|*1e-4, epsfix)`)
  - Key quirks: bounds modified in-place by `dirpreprc_()`, volume check uses jones=0,
    budget elasticity for infeasible problems, MAXDIV=5000 limitation
- Created detailed pseudocode control flow diagram

### Files created
- direct-nlopt-rs/analysis/gablonsky_analysis.md

### Files modified
- plans/prd-direct-nlopt.json (marked first analysis item as passes: true)

### Git commits
- `ad0897f` docs(analysis): analyze DIRect.c main loop, memory layout, and control flow

### Test results
- N/A (analysis-only task, no code changes)

### Notes
- The 1-based indexing permeates the entire codebase and must be carefully handled in Rust
- `l` and `u` arrays are destructively overwritten by `dirpreprc_()` — Rust impl should
  store scaling coefficients separately to avoid this confusing pattern
- Volume tolerance check always uses jones=0 regardless of algorithm — potential intentional
  design or bug; Rust impl should match this exactly for faithfulness
- The `s` array (selected rectangles) has a hardcoded limit of MAXDIV=5000 — only relevant
  for DIRECT_ORIGINAL with `dirdoubleinsert_()`


## Iteration 2 — Analysis of DIRsubrout.c Subroutines (2026-02-21)

### What was implemented
- Thoroughly analyzed `nlopt/src/algs/direct/DIRsubrout.c` (1595 lines) function-by-function:
  - `direct_dirgetlevel_()`: Level computation for both algmethod variants. Jones Original
    returns min(length[i]), Gablonsky returns k*n+p encoding both min index and count.
  - `direct_dirchoose_()`: Potentially optimal rectangle selection via pairwise slope-based
    convex hull sweep (not monotone chain). Collects anchor heads per depth, eliminates
    candidates above hull or failing epsilon test. Special handling when no feasible point
    exists (selects only one rect).
  - `direct_dirdoubleinsert_()`: Jones Original only — walks linked lists at each selected
    rect's depth level to find additional rects with f-value within 1e-13 tolerance.
  - `direct_dirgetmaxdeep_()`: Returns min(length[i]) across all dimensions — the "depth"
    of a rectangle (identical to dirgetlevel_ with jones=1).
  - `direct_dirget_i__()`: Finds all dimensions with the minimum length index (longest
    sides). Returns dimension indices and count in arrayi/maxi.
  - `direct_dirsamplepoints_()`: Allocates 2*maxi new rectangle slots from free list,
    copies parent center/lengths, then offsets center coordinates ± delta along each
    divided dimension.
  - `direct_dirdivide_()`: Sorts dimensions by min(f+,f-) using insertion sort
    (dirinsertlist_2__), then trisects in sorted order. Critical detail: dims divided
    first get length incremented in ALL subsequent children.
  - `direct_dirinsertlist_()`: Inserts 2*maxi+1 rectangles (maxi child pairs + parent)
    into depth-indexed anchor lists maintaining f-value sorted order. Handles 6 ordering
    cases for each pair vs existing anchor.
  - `direct_dirreplaceinf_()`: For each infeasible rect, computes bounding box from side
    lengths, searches for nearby feasible points, replaces f-value with min nearby + 1e-6
    perturbation, re-sorts affected lists. Uses isinbox_() helper.
  - `direct_dirinfcn_()`: Unscale x from [0,1]^n to [l,u] via (x+xs2)*xs1, call user
    function, rescale back. Thread-unsafe (modifies x in place).
  - `direct_dirpreprc_()`: Compute scaling: xs1=u-l, xs2=l/(u-l). Validates u>l.
  - `direct_dirheader_()`: Input validation, epsilon sign handling (negative → dynamic
    Jones update), bounds checking, capacity check.
  - `direct_dirinit_()`: Full initialization — precompute thirds[]/levels[], evaluate
    center (0.5,...,0.5), sample 2n neighbors, divide first rectangle, insert into lists.
    Total evals: 2n+1.
  - `direct_dirinitlist_()`: Initialize anchors to 0, f-values to 0, point[] as free
    list chain 1→2→...→MAXFUNC→0, free=1.
  - `direct_dirsummary_()`: Final logging (no algorithmic logic).
- Documented 5 private helper functions: dirinsert_(), dirinsertlist_2__(),
  dirsearchmin_(), isinbox_(), dirresortlist_()
- Created complete function call graph showing all caller/callee relationships

### Files created
- direct-nlopt-rs/analysis/dirsubrout_analysis.md

### Files modified
- plans/prd-direct-nlopt.json (marked second analysis item as passes: true)

### Git commits
- `ac296ab` docs(analysis): analyze DIRsubrout.c subroutines function-by-function

### Test results
- N/A (analysis-only task, no code changes)

### Notes
- The `dirgetlevel_()` `p` variable counts dimensions matching `help` (dim 1's value),
  NOT the minimum `k`. This subtlety is critical for correct Gablonsky level computation.
- `dirinfcn_()` modifies `x` in-place for unscaling/rescaling — the Rust port must use a
  separate scratch buffer for thread safety.
- `dirreplaceinf_()` line 620-621 computes `x[l] = c[l,i]*c1[l] + c[l,i]*c2[l]` which
  appears to be dead code (result stored in x but never used after).
- `dirdoubleinsert_()` uses 1e-13 tolerance for "equal value" — this is hardcoded.
- The `levels[]` array has different structure depending on jones: 2D for jones=0
  (Gablonsky), 1D for jones=1 (Jones Original).


## Iteration 3 — Analysis of DIRserial.c: Serial Function Evaluation (2026-02-21)

### What was implemented
- Thoroughly analyzed `nlopt/src/algs/direct/DIRserial.c` (150 lines) line by line:
  - `direct_dirsamplef_()`: complete function signature with all 26 parameters documented
  - Identified 7 unused parameters in serial version: `logfile`, `free`, `maxfunc`, `maxdeep`,
    `oops`, `delta`, `sample` — these exist for API compatibility with DIRparallel.c
  - Documented f2c 1-based parameter adjustments: `--u`, `--l`, `--x`, `--arrayi`, `--point`,
    `f -= 3` (critical: makes f[(pos<<1)+1]=value, f[(pos<<1)+2]=flag)
  - Documented c__ access pattern: `c__[i + pos * c_dim1]` where c_dim1 = n (row-major, dim-fast)
- Documented the two-pass algorithm structure:
  - **Pass 1** (lines 67–133): Iterate over all 2×maxi new sample points via linked list.
    For each point: copy center to x buffer → call dirinfcn_() (unscale, evaluate, rescale) →
    store result based on kret (0=feasible, ≥1=infeasible, -1=setup error) → update fmax/ifeasiblef/iinfesiblef
  - **Pass 2** (lines 134–149): Re-iterate over same 2×maxi points, update minf/minpos
    considering only feasible points (f[2*pos+2] == 0.0)
- Documented the exact evaluation order from dirsamplepoints_():
  - Chain: start → plus_d1 → minus_d1 → plus_d2 → minus_d2 → ... → plus_dM → minus_dM
  - Positive offset first, then negative, for each of the maxi longest dimensions
- Documented error handling:
  - force_stop: skips evaluation (assigns fmax), overrides kret to -1
  - kret=0: feasible → f_flag=0, update fmax
  - kret≥1: infeasible → f_flag=2, f_value=fmax (uses current accumulated fmax)
  - kret=-1: setup error → f_flag=-1
- Identified independent vs sequential operations for parallelization:
  - **Independent**: All 2×maxi function evaluations (each has own position, coordinates, result slot)
  - **Sequential**: fmax accumulation (used for infeasible replacement), ifeasiblef, iinfesiblef tracking,
    minf/minpos update (Pass 2)
  - **Key subtlety**: Infeasible f-value assignment uses accumulated fmax, so serial vs parallel
    may assign different placeholder values. This is acceptable since dirreplaceinf_() later
    replaces these values anyway.
- Compared with DIRparallel.c (381 lines): PVM-based parallel version with master/slave message
  passing. Not used in NLOPT. Different f-array indexing (column-major vs transposed row-major).
- Outlined Rust port strategy for both serial (exact match) and parallel (rayon par_iter) paths

### Files created
- direct-nlopt-rs/analysis/dirserial_analysis.md

### Files modified
- plans/prd-direct-nlopt.json (marked third analysis item as passes: true)

### Git commits
- `a74dc85` docs(analysis): analyze DIRserial.c serial function evaluation

### Test results
- N/A (analysis-only task, no code changes)

### Notes
- The scratch buffer `x[1..n]` is the only shared mutable state — Rust parallel version must
  allocate per-thread copies (handled naturally by collecting centers into Vec before par_iter)
- The `force_stop` check should use AtomicBool or similar in parallel mode for safe cross-thread access
- For exact serial equivalence (parallel=false), the linked list traversal order must be preserved
- The infeasible fmax assignment order dependence is the only semantic difference between
  serial and parallel — and it doesn't affect final results due to dirreplaceinf_() post-processing


## Iteration 4 — Analysis of hybrid.c: DIRECT + Local Optimization Hybrid (2026-02-21)

### What was implemented
- Thoroughly analyzed `nlopt/src/algs/cdirect/hybrid.c` (345 lines) function-by-function
- Documented the extended hyperrect layout `3n+3`: (diameter, -f, -age, x[n], c[n], w[n])
  - Key difference from cdirect.c: adds `x[n]` local optimum storage between metadata and center
  - f-value and age stored negated so red-black tree max node = largest diameter + best f
- Documented `fcount()`: thin wrapper counting evaluations for local optimizer
- Documented `optimize_rect()`: runs local optimizer within rectangle bounds
  - Computes local bounds from `c ± 0.5*w`
  - Configures local optimizer with remaining eval/time budget
  - Updates stored f-value and global best on success
- Documented `randomize_x()`: sets starting point to random location within middle third of rect
- Documented `longest()`: Gablonsky-style max-side diameter (always used, no Jones option)
- Documented `divide_largest()`: core iteration function
  - Always takes largest rect from tree (no convex hull or epsilon test)
  - Selects ONE dimension to divide (first or random longest), unlike standard DIRECT's all-longest
  - **Bisect vs trisect decision**: if local optimum `x` is far from center `c` (> w/6), bisect; else trisect
  - Bisection shifts center toward optimum, halves width
  - Trisection creates two children at ±w_new offsets
  - Identified potential bug in trisection path: `w[i]` uses loop variable `i∈{-1,+1}` as array index
- Documented `cdirect_hybrid_unscaled()`: main entry point with simple do-while loop
  - Identified potential diameter computation bug: `longest(n, rnew+2*n)` should be `longest(n, rnew+3+2*n)`
- Documented `cdirect_hybrid()`: rescaling wrapper identical to `cdirect()` pattern
- Created comprehensive comparison table: hybrid vs standard DIRECT differences
- Made scope decision: **EXCLUDE hybrid from Rust implementation**
  - Requires local optimizer integration (outside DIRECT library scope)
  - Has suspected bugs in trisection offset and diameter computation
  - Rarely used in practice
  - Architecturally distinct (no PO selection, no convex hull, no epsilon)

### Files created
- direct-nlopt-rs/analysis/hybrid_analysis.md

### Files modified
- plans/prd-direct-nlopt.json (marked hybrid.c analysis as passes: true)

### Git commits
- `86be866` docs(analysis): analyze hybrid.c DIRECT + local optimization hybrid

### Test results
- N/A (analysis-only task, no code changes)

### Notes
- hybrid.c stores f-values and ages NEGATED (r[1]=-f, r[2]=-age) unlike cdirect.c which stores them directly
- The bisect/trisect decision based on local optimum position is the key innovation
- Two potential bugs identified in NLOPT source:
  1. `divide_largest()` line 211: `w[i]` with `i∈{-1,+1}` reads wrong memory for trisection offset
  2. `cdirect_hybrid_unscaled()` line 266: `longest(n, rnew+2*n)` has wrong offset for widths array
- These bugs may be masked by local optimization or rarely-triggered code paths
- The hybrid is the only NLOPT DIRECT variant that uses bisection (all others use trisection exclusively)

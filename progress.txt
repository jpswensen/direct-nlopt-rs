# Progress Log - direct-nlopt-rs: NLOPT DIRECT algorithm family in Rust


## Iteration 0 — Project Setup & Ralph Initialization (2026-02-21)

### What was implemented
- Initialized git repository in `direct-nlopt-rs/` with basic Rust project structure
- Created feature branch `feature/nlopt-direct-faithful-implementation` for all ralph-driven changes
- Created Cargo.toml with dependencies: rayon, parking_lot, thiserror, ordered-float, libc, etc.
- Created src/lib.rs crate root with module declarations
- Created src/error.rs with DirectReturnCode and DirectError types matching NLOPT's direct_return_code enum
- Created benches/benchmarks.rs placeholder for Criterion benchmarks
- Created .gitignore
- Thoroughly analyzed both NLOPT DIRECT implementations:
  - Gablonsky Fortran→C translation (DIRect.c, DIRsubrout.c, DIRserial.c, direct_wrap.c): ~2600 lines
  - SGJ C re-implementation (cdirect.c, hybrid.c): ~950 lines
- Generated permanent context prompt (prompts/direct-nlopt-rs.txt) with full project context,
  NLOPT C → Rust function mapping tables for both implementations, data structure correspondence,
  algorithm flow documentation, parallelization strategy, and task instructions
- Generated PRD plan (plans/prd-direct-nlopt.json) with 54 ordered tasks across 12 categories:
  analysis (5), implementation (10), test-foundation (1), test-unit (7), test-integration (11),
  parallelization (4), performance (3), ffi (1), edge-cases (3), test-regression (3), documentation (2)
- Verified Rust project builds successfully

### Files created
- direct-nlopt-rs/.gitignore
- direct-nlopt-rs/Cargo.toml
- direct-nlopt-rs/src/lib.rs
- direct-nlopt-rs/src/error.rs
- direct-nlopt-rs/benches/benchmarks.rs
- prompts/direct-nlopt-rs.txt (permanent context prompt for ralph)
- plans/prd-direct-nlopt.json (54-item PRD plan)

### Git commits
- `df12538` chore(init): initialize direct-nlopt-rs project with basic structure

### Test results
- Project builds successfully (cargo build)
- No tests yet (baseline)

### Notes
- Two NLOPT DIRECT codepaths must be ported: Gablonsky translation AND SGJ re-implementation
- The Gablonsky translation uses SoA + linked lists (similar to scipy port in direct-rs/)
- The SGJ re-implementation uses red-black trees (cleaner but different data structure)
- Both codepaths must produce identical results to their NLOPT C counterparts
- Parallelization via rayon should be added at function evaluation points
- The venv/ folder has Python 3.12 for any comparison scripts needed


## Iteration 1 — Analysis of DIRect.c Main Loop and Memory Layout (2026-02-21)

### What was implemented
- Thoroughly analyzed `nlopt/src/algs/direct/DIRect.c` line by line, documenting:
  - Complete `direct_direct_()` function: signature, all parameters, return codes
  - Full variable map: every dynamically allocated array (`c__`, `f`, `length`, `point`,
    `anchor`, `s`, `thirds`, `levels`, `w`, `oldl`, `oldu`, `list2`, `arrayi`) with sizes,
    indexing conventions (1-based Fortran heritage), and purpose
  - All scalar variables: `jones`, `ifree`, `minpos`, `fmax`, `numfunc`, `actdeep`,
    `actmaxdeep`, `maxi`, `maxpos`, `ifeasiblef`, `iinfesiblef`, `iepschange`, etc.
  - Memory allocation scheme: `MAXFUNC = maxf + 1000 + maxf/2`, `MAXDEEP = MAXFUNC/5`,
    `MAXDIV = 5000` constant
  - SGJ's transposition of arrays from Fortran column-major to C row-major layout
  - Initialization sequence: `dirheader_()` → `dirinitlist_()` → `dirpreprc_()` → `dirinit_()`
  - Main iteration loop: `dirchoose_()` → `dirdoubleinsert_()` (Original only) →
    for-each-selected-rect: remove → `dirget_i_()` → `dirsamplepoints_()` →
    `dirsamplef_()` → `dirdivide_()` → `dirinsertlist_()`
  - Termination checks in exact order: volume_tol → sigma_tol → fglobal → replace_inf →
    epsilon update → budget increase → maxfeval
  - Epsilon update logic: fixed when eps>0 (`iepschange=0`), Jones formula when eps<0
    (`iepschange=1`, `eps = max(|minf|*1e-4, epsfix)`)
  - Key quirks: bounds modified in-place by `dirpreprc_()`, volume check uses jones=0,
    budget elasticity for infeasible problems, MAXDIV=5000 limitation
- Created detailed pseudocode control flow diagram

### Files created
- direct-nlopt-rs/analysis/gablonsky_analysis.md

### Files modified
- plans/prd-direct-nlopt.json (marked first analysis item as passes: true)

### Git commits
- `ad0897f` docs(analysis): analyze DIRect.c main loop, memory layout, and control flow

### Test results
- N/A (analysis-only task, no code changes)

### Notes
- The 1-based indexing permeates the entire codebase and must be carefully handled in Rust
- `l` and `u` arrays are destructively overwritten by `dirpreprc_()` — Rust impl should
  store scaling coefficients separately to avoid this confusing pattern
- Volume tolerance check always uses jones=0 regardless of algorithm — potential intentional
  design or bug; Rust impl should match this exactly for faithfulness
- The `s` array (selected rectangles) has a hardcoded limit of MAXDIV=5000 — only relevant
  for DIRECT_ORIGINAL with `dirdoubleinsert_()`


## Iteration 2 — Analysis of DIRsubrout.c Subroutines (2026-02-21)

### What was implemented
- Thoroughly analyzed `nlopt/src/algs/direct/DIRsubrout.c` (1595 lines) function-by-function:
  - `direct_dirgetlevel_()`: Level computation for both algmethod variants. Jones Original
    returns min(length[i]), Gablonsky returns k*n+p encoding both min index and count.
  - `direct_dirchoose_()`: Potentially optimal rectangle selection via pairwise slope-based
    convex hull sweep (not monotone chain). Collects anchor heads per depth, eliminates
    candidates above hull or failing epsilon test. Special handling when no feasible point
    exists (selects only one rect).
  - `direct_dirdoubleinsert_()`: Jones Original only — walks linked lists at each selected
    rect's depth level to find additional rects with f-value within 1e-13 tolerance.
  - `direct_dirgetmaxdeep_()`: Returns min(length[i]) across all dimensions — the "depth"
    of a rectangle (identical to dirgetlevel_ with jones=1).
  - `direct_dirget_i__()`: Finds all dimensions with the minimum length index (longest
    sides). Returns dimension indices and count in arrayi/maxi.
  - `direct_dirsamplepoints_()`: Allocates 2*maxi new rectangle slots from free list,
    copies parent center/lengths, then offsets center coordinates ± delta along each
    divided dimension.
  - `direct_dirdivide_()`: Sorts dimensions by min(f+,f-) using insertion sort
    (dirinsertlist_2__), then trisects in sorted order. Critical detail: dims divided
    first get length incremented in ALL subsequent children.
  - `direct_dirinsertlist_()`: Inserts 2*maxi+1 rectangles (maxi child pairs + parent)
    into depth-indexed anchor lists maintaining f-value sorted order. Handles 6 ordering
    cases for each pair vs existing anchor.
  - `direct_dirreplaceinf_()`: For each infeasible rect, computes bounding box from side
    lengths, searches for nearby feasible points, replaces f-value with min nearby + 1e-6
    perturbation, re-sorts affected lists. Uses isinbox_() helper.
  - `direct_dirinfcn_()`: Unscale x from [0,1]^n to [l,u] via (x+xs2)*xs1, call user
    function, rescale back. Thread-unsafe (modifies x in place).
  - `direct_dirpreprc_()`: Compute scaling: xs1=u-l, xs2=l/(u-l). Validates u>l.
  - `direct_dirheader_()`: Input validation, epsilon sign handling (negative → dynamic
    Jones update), bounds checking, capacity check.
  - `direct_dirinit_()`: Full initialization — precompute thirds[]/levels[], evaluate
    center (0.5,...,0.5), sample 2n neighbors, divide first rectangle, insert into lists.
    Total evals: 2n+1.
  - `direct_dirinitlist_()`: Initialize anchors to 0, f-values to 0, point[] as free
    list chain 1→2→...→MAXFUNC→0, free=1.
  - `direct_dirsummary_()`: Final logging (no algorithmic logic).
- Documented 5 private helper functions: dirinsert_(), dirinsertlist_2__(),
  dirsearchmin_(), isinbox_(), dirresortlist_()
- Created complete function call graph showing all caller/callee relationships

### Files created
- direct-nlopt-rs/analysis/dirsubrout_analysis.md

### Files modified
- plans/prd-direct-nlopt.json (marked second analysis item as passes: true)

### Git commits
- `ac296ab` docs(analysis): analyze DIRsubrout.c subroutines function-by-function

### Test results
- N/A (analysis-only task, no code changes)

### Notes
- The `dirgetlevel_()` `p` variable counts dimensions matching `help` (dim 1's value),
  NOT the minimum `k`. This subtlety is critical for correct Gablonsky level computation.
- `dirinfcn_()` modifies `x` in-place for unscaling/rescaling — the Rust port must use a
  separate scratch buffer for thread safety.
- `dirreplaceinf_()` line 620-621 computes `x[l] = c[l,i]*c1[l] + c[l,i]*c2[l]` which
  appears to be dead code (result stored in x but never used after).
- `dirdoubleinsert_()` uses 1e-13 tolerance for "equal value" — this is hardcoded.
- The `levels[]` array has different structure depending on jones: 2D for jones=0
  (Gablonsky), 1D for jones=1 (Jones Original).


## Iteration 3 — Analysis of DIRserial.c: Serial Function Evaluation (2026-02-21)

### What was implemented
- Thoroughly analyzed `nlopt/src/algs/direct/DIRserial.c` (150 lines) line by line:
  - `direct_dirsamplef_()`: complete function signature with all 26 parameters documented
  - Identified 7 unused parameters in serial version: `logfile`, `free`, `maxfunc`, `maxdeep`,
    `oops`, `delta`, `sample` — these exist for API compatibility with DIRparallel.c
  - Documented f2c 1-based parameter adjustments: `--u`, `--l`, `--x`, `--arrayi`, `--point`,
    `f -= 3` (critical: makes f[(pos<<1)+1]=value, f[(pos<<1)+2]=flag)
  - Documented c__ access pattern: `c__[i + pos * c_dim1]` where c_dim1 = n (row-major, dim-fast)
- Documented the two-pass algorithm structure:
  - **Pass 1** (lines 67–133): Iterate over all 2×maxi new sample points via linked list.
    For each point: copy center to x buffer → call dirinfcn_() (unscale, evaluate, rescale) →
    store result based on kret (0=feasible, ≥1=infeasible, -1=setup error) → update fmax/ifeasiblef/iinfesiblef
  - **Pass 2** (lines 134–149): Re-iterate over same 2×maxi points, update minf/minpos
    considering only feasible points (f[2*pos+2] == 0.0)
- Documented the exact evaluation order from dirsamplepoints_():
  - Chain: start → plus_d1 → minus_d1 → plus_d2 → minus_d2 → ... → plus_dM → minus_dM
  - Positive offset first, then negative, for each of the maxi longest dimensions
- Documented error handling:
  - force_stop: skips evaluation (assigns fmax), overrides kret to -1
  - kret=0: feasible → f_flag=0, update fmax
  - kret≥1: infeasible → f_flag=2, f_value=fmax (uses current accumulated fmax)
  - kret=-1: setup error → f_flag=-1
- Identified independent vs sequential operations for parallelization:
  - **Independent**: All 2×maxi function evaluations (each has own position, coordinates, result slot)
  - **Sequential**: fmax accumulation (used for infeasible replacement), ifeasiblef, iinfesiblef tracking,
    minf/minpos update (Pass 2)
  - **Key subtlety**: Infeasible f-value assignment uses accumulated fmax, so serial vs parallel
    may assign different placeholder values. This is acceptable since dirreplaceinf_() later
    replaces these values anyway.
- Compared with DIRparallel.c (381 lines): PVM-based parallel version with master/slave message
  passing. Not used in NLOPT. Different f-array indexing (column-major vs transposed row-major).
- Outlined Rust port strategy for both serial (exact match) and parallel (rayon par_iter) paths

### Files created
- direct-nlopt-rs/analysis/dirserial_analysis.md

### Files modified
- plans/prd-direct-nlopt.json (marked third analysis item as passes: true)

### Git commits
- `a74dc85` docs(analysis): analyze DIRserial.c serial function evaluation

### Test results
- N/A (analysis-only task, no code changes)

### Notes
- The scratch buffer `x[1..n]` is the only shared mutable state — Rust parallel version must
  allocate per-thread copies (handled naturally by collecting centers into Vec before par_iter)
- The `force_stop` check should use AtomicBool or similar in parallel mode for safe cross-thread access
- For exact serial equivalence (parallel=false), the linked list traversal order must be preserved
- The infeasible fmax assignment order dependence is the only semantic difference between
  serial and parallel — and it doesn't affect final results due to dirreplaceinf_() post-processing


## Iteration 4 — Analysis of hybrid.c: DIRECT + Local Optimization Hybrid (2026-02-21)

### What was implemented
- Thoroughly analyzed `nlopt/src/algs/cdirect/hybrid.c` (345 lines) function-by-function
- Documented the extended hyperrect layout `3n+3`: (diameter, -f, -age, x[n], c[n], w[n])
  - Key difference from cdirect.c: adds `x[n]` local optimum storage between metadata and center
  - f-value and age stored negated so red-black tree max node = largest diameter + best f
- Documented `fcount()`: thin wrapper counting evaluations for local optimizer
- Documented `optimize_rect()`: runs local optimizer within rectangle bounds
  - Computes local bounds from `c ± 0.5*w`
  - Configures local optimizer with remaining eval/time budget
  - Updates stored f-value and global best on success
- Documented `randomize_x()`: sets starting point to random location within middle third of rect
- Documented `longest()`: Gablonsky-style max-side diameter (always used, no Jones option)
- Documented `divide_largest()`: core iteration function
  - Always takes largest rect from tree (no convex hull or epsilon test)
  - Selects ONE dimension to divide (first or random longest), unlike standard DIRECT's all-longest
  - **Bisect vs trisect decision**: if local optimum `x` is far from center `c` (> w/6), bisect; else trisect
  - Bisection shifts center toward optimum, halves width
  - Trisection creates two children at ±w_new offsets
  - Identified potential bug in trisection path: `w[i]` uses loop variable `i∈{-1,+1}` as array index
- Documented `cdirect_hybrid_unscaled()`: main entry point with simple do-while loop
  - Identified potential diameter computation bug: `longest(n, rnew+2*n)` should be `longest(n, rnew+3+2*n)`
- Documented `cdirect_hybrid()`: rescaling wrapper identical to `cdirect()` pattern
- Created comprehensive comparison table: hybrid vs standard DIRECT differences
- Made scope decision: **EXCLUDE hybrid from Rust implementation**
  - Requires local optimizer integration (outside DIRECT library scope)
  - Has suspected bugs in trisection offset and diameter computation
  - Rarely used in practice
  - Architecturally distinct (no PO selection, no convex hull, no epsilon)

### Files created
- direct-nlopt-rs/analysis/hybrid_analysis.md

### Files modified
- plans/prd-direct-nlopt.json (marked hybrid.c analysis as passes: true)

### Git commits
- `86be866` docs(analysis): analyze hybrid.c DIRECT + local optimization hybrid

### Test results
- N/A (analysis-only task, no code changes)

### Notes
- hybrid.c stores f-values and ages NEGATED (r[1]=-f, r[2]=-age) unlike cdirect.c which stores them directly
- The bisect/trisect decision based on local optimum position is the key innovation
- Two potential bugs identified in NLOPT source:
  1. `divide_largest()` line 211: `w[i]` with `i∈{-1,+1}` reads wrong memory for trisection offset
  2. `cdirect_hybrid_unscaled()` line 266: `longest(n, rnew+2*n)` has wrong offset for widths array
- These bugs may be masked by local optimization or rarely-triggered code paths
- The hybrid is the only NLOPT DIRECT variant that uses bisection (all others use trisection exclusively)


## Iteration 2 — Implement types.rs: Core Type Definitions (2026-02-21)

### What was implemented
- Created `src/types.rs` with all core type definitions matching NLOPT's API
- Defined `DirectAlgorithm` enum with 8 variants covering all NLOPT DIRECT algorithms:
  - SGJ cdirect.c variants: Original, LocallyBiased, Randomized + their Unscaled counterparts
  - Gablonsky translation variants: GablonskyOriginal, GablonskyLocallyBiased
- Mapped each variant to NLOPT's internal encoding:
  - `which_alg()` → base-3 encoding for cdirect.c (0, 13, 16)
  - `algmethod()` → 0 (DIRECT_ORIGINAL) or 1 (DIRECT_GABLONSKY) for Gablonsky translation
- Defined `DirectOptions` struct matching NLOPT's `direct_optimize()` parameters:
  - max_feval, max_iter, max_time, magic_eps, magic_eps_abs
  - volume_reltol (default 0.0), sigma_reltol (default -1.0)
  - fglobal (default DIRECT_UNKNOWN_FGLOBAL = -inf), fglobal_reltol (default 0.0)
  - algorithm, parallel
- Defined `DirectResult` struct: x, fun, nfev, nit, success, return_code, message
- Defined type aliases: `Bounds = Vec<(f64, f64)>`, `ObjectiveFn`, `CallbackFn`
- Defined constants: `DIRECT_UNKNOWN_FGLOBAL`, `DIRECT_UNKNOWN_FGLOBAL_RELTOL`
- Implemented `Display` for `DirectReturnCode`, `DirectAlgorithm`, and `DirectResult`
- Implemented `Default` for `DirectOptions` matching NLOPT defaults exactly
- Added 13 unit tests covering type conversions, which_alg decomposition, defaults, Display
- Updated lib.rs to declare the types module and re-export all public types

### Files created
- direct-nlopt-rs/src/types.rs

### Files modified
- direct-nlopt-rs/src/lib.rs (added types module and re-exports)
- plans/prd-direct-nlopt.json (marked types.rs implementation as passes: true)

### Git commits
- `a9f0cf7` feat(types): implement core type definitions matching NLOPT API

### Test results
- 13 tests passed, 0 failed (+13 new tests)
- cargo clippy clean (no warnings)

### Notes
- Default algorithm is LocallyBiased (DIRECT-L), the most commonly used variant
- DIRECT_UNKNOWN_FGLOBAL maps to f64::NEG_INFINITY matching C's -HUGE_VAL
- sigma_reltol defaults to -1.0 (disabled) matching nlopt_get_param(opt, "sigma_reltol", -1.0)
- volume_reltol defaults to 0.0, but NLOPT internally converts <=0 to -1 in direct_wrap.c


## Iteration 3 — Implement storage.rs: SoA Rectangle Storage (2026-02-21)

### What was implemented
- Created `src/storage.rs` implementing `RectangleStorage` struct with SoA layout matching
  NLOPT's Gablonsky Fortran→C translation data structures from DIRect.c and DIRsubrout.c
- `RectangleStorage::new()` — memory allocation matching NLOPT's formulas:
  MAXFUNC = maxf <= 0 ? 101000 : (maxf + 1000 + maxf/2),
  MAXDEEP = maxt <= 0 ? MAXFUNC/5 : (maxt + 1000)
- `init_lists()` — matches `direct_dirinitlist_()`: zeroes anchors[-1..maxdeep],
  chains point[] as free list (1→2→...→maxfunc-1→0), zeroes f_values
- `precompute_thirds()` — computes thirds[k] = 1/3^k for k=0..maxdeep
- `precompute_levels()` — computes levels[] for both jones=0 (Original: w[j]/3^(i-1)
  where w[j]=sqrt(n-j+j/9)*0.5) and jones=1 (Gablonsky: 1/3^k)
- `get_level()` — matches `direct_dirgetlevel_()` exactly:
  jones=1 returns min(lengths), jones=0 returns k*n+p encoding
- `get_max_deep()` — matches `direct_dirgetmaxdeep_()`: returns min of length indices
- `get_longest_dims()` — matches `direct_dirget_i__()`: finds all dimensions with
  minimum length index, returns 1-based indices and count
- `insert_into_list()` — matches `direct_dirinsertlist_()`: inserts maxi pairs of
  child rectangles plus parent into anchor-linked lists sorted by f-value at computed depth
- `insert_sorted()` — matches `dirinsert_()`: sorted insertion helper
- `alloc_rect()` / `free_rect()` — free list allocation/deallocation
- `replace_infeasible()` — matches `direct_dirreplaceinf_()`: scans for infeasible points,
  checks bounding box of each rectangle for nearby feasible points, replaces f-value
  with min nearby feasible + 1e-6 perturbation, or sets to max(fmax+1, f)
- `resort_list()` — matches `dirresortlist_()`: removes and re-inserts rectangle after
  f-value replacement to maintain sorted order
- Helper accessors: f_val(), f_flag(), set_f(), center(), set_center(), length(),
  set_length(), copy_center(), copy_lengths(), remove_from_anchor()
- 21 unit tests covering all functions

### Files created
- direct-nlopt-rs/src/storage.rs

### Files modified
- direct-nlopt-rs/src/lib.rs (added `pub mod storage`)
- plans/prd-direct-nlopt.json (marked storage.rs task as passes: true)

### Git commits
- `a9acb4f` feat(storage): implement SoA rectangle storage with linked-list management

### Test results
- 42 tests passed, 0 failed (+21 new storage tests)
- All clippy warnings resolved

### Notes
- Uses 1-based indexing internally to match NLOPT's Fortran-translated C code
- Index 0 is unused in point/anchor arrays; 0 serves as null sentinel
- anchor array offset: anchor[depth+1] maps to NLOPT's anchor[depth] with -1 → index 0
- replace_infeasible uses xs1/xs2 params (currently prefixed with _ since only used
  in the unscaling step of dirresortlist_ which is delegated to direct.rs)
- The insert_into_list function faithfully reproduces the complex sorting logic from
  DIRsubrout.c including all 6 comparison branches for the pos1/pos2 pair insertion


## Iteration 3 — Implement PotentiallyOptimal Selection (2026-02-21)

### What was implemented
- Implemented `PotentiallyOptimal` struct in storage.rs matching NLOPT's `s` array (MAXDIV × 2)
  with `indices` (rect indices, 1-based) and `rect_levels` (level from get_level())
- Implemented `PotentiallyOptimal::select()` matching `direct_dirchoose_()` in DIRsubrout.c
  lines 102–261 exactly:
  - All-infeasible path: picks first non-empty anchor, returns single selection (lines 134–148)
  - Normal path: collects non-empty anchor heads across depths 0..act_deep (lines 150–159)
  - Infeasible anchor check: anchor[0] in Rust = anchor[-1] in C (lines 162–166)
  - Convex hull elimination sweep: iterates from maxpos down to 1, for each candidate j:
    - Computes minimum slope (helplower) to candidates with larger diameter (lines 178–204)
    - Computes maximum slope (helpgreater) to candidates with smaller diameter (lines 206–231)
    - Eliminates if slope ≤ 0 in either direction (goto L60 equivalent)
    - Eliminates if helpgreater > helplower (above convex hull)
    - Epsilon test: f[j] - K*levels[level_j] > min(minf - eps*|minf|, minf - epsabs)
  - Appends infeasible anchor at the end if present (lines 256–260)
  - Note: NLOPT's `cheat` flag (always 0 in DIRect.c line 140) is documented but skipped
  - Note: In dirchoose_, the `thirds` parameter actually receives the `levels[]` array
    from the caller (DIRect.c line 455) — Rust uses storage.levels directly
- Implemented `PotentiallyOptimal::double_insert()` matching `direct_dirdoubleinsert_()`
  in DIRsubrout.c lines 274–332 exactly:
  - For each selected rect, walks the linked list at the same depth level
  - Adds rects with f-value within 1e-13 of the anchor head (lines 312–328)
  - Returns Err(-6) if selection array capacity exceeded (lines 322–323)
  - Only used with algmethod=0 (DIRECT Original, Jones 1993)
- Added 15 unit tests covering all scenarios from the PRD:
  - Monotonically decreasing f → all selected (convex hull)
  - Rect above hull → excluded
  - Multiple rects at same level → only anchor head considered
  - Epsilon test elimination
  - Gaps in depth distribution
  - All infeasible → picks first available
  - Infeasible anchor appended
  - Jones Original (jones=0) level computation
  - Double insert with equal/different f-values
  - Double insert capacity overflow (Err(-6))
  - Single rect edge case
  - Empty storage edge case
  - Multiple levels with double insert

### Files modified
- direct-nlopt-rs/src/storage.rs (added PotentiallyOptimal struct + select() + double_insert() + 15 tests)
- plans/prd-direct-nlopt.json (marked PotentiallyOptimal task as passes: true)

### Git commits
- `d3f0f86` feat(storage): implement PotentiallyOptimal selection matching dirchoose_

### Test results
- 57 tests passed, 0 failed (+15 new tests)
- cargo clippy clean (0 warnings)

### Notes
- The `cheat`/`kmax` feature in dirchoose_ is always disabled (cheat=0 in DIRect.c:140)
- The clearing loop in C (lines 168–172) has a Fortran translation artifact: loop var j
  but writes to fixed s[k]; in Rust we just clear remaining slots
- The `thirds` parameter in dirchoose_ is confusingly named — it actually receives the
  `levels[]` array from the caller; this is correctly handled in the Rust implementation
- Feasibility check `f_flag <= 1.0` correctly includes both FEASIBLE (0.0) and REPLACED (1.0)
- Level indexing: levels[] is indexed by get_level() return value, which for Gablonsky is
  the min length index (bounded by actual search depth), well within levels[] array bounds


## Iteration 5 — Implement direct.rs: Preprocessing, Scaling, and Evaluation (2026-02-21)

### What was implemented
- Created `src/direct.rs` module implementing the `Direct` struct — the core optimizer state for the Gablonsky translation path
- Implemented `Direct::new()` with preprocessing matching `direct_dirpreprc_()` (DIRsubrout.c lines 1403-1442):
  - `xs1[i] = u[i] - l[i]` (scaling factor per dimension)
  - `xs2[i] = l[i] / (u[i] - l[i])` (offset factor per dimension)
  - Validates bounds (lower < upper) for all dimensions
- Implemented `Direct::validate_inputs()` matching `direct_dirheader_()` (DIRsubrout.c lines 1444-1565):
  - Epsilon sign handling: negative eps → Jones update formula (`iepschange=1, epsfix=|eps|`)
  - Positive/zero eps → constant epsilon (`iepschange=0, epsfix=1e100`)
  - Memory size check: `maxf + 20 > maxfunc` → error
- Implemented `Direct::to_actual()` matching `direct_dirinfcn_()` unscaling (lines 1071-1074):
  - Formula: `x_actual[i] = (x_norm[i] + xs2[i]) * xs1[i]`
  - Algebraic equivalence verified: `(x + l/(u-l)) * (u-l) = x*(u-l) + l`
- Implemented `Direct::to_normalized()` matching `direct_dirinfcn_()` rescaling (lines 1084-1087):
  - Formula: `x_norm[i] = x_actual[i] / xs1[i] - xs2[i]`
- Implemented `Direct::evaluate()` matching `direct_dirinfcn_()`:
  - Converts normalized → actual, calls user function, checks feasibility (NaN/Inf → infeasible)
- Implemented tolerance conversion helpers matching `direct_wrap.c` (lines 67-77):
  - `volume_reltol_pct()`, `sigma_reltol_pct()`, `fglobal_reltol_pct()`
  - Volume/sigma: multiply by 100, set to -1 if ≤ 0
  - fglobal_reltol: set to 0.0 if fglobal is DIRECT_UNKNOWN_FGLOBAL
- Implemented `Direct::update_epsilon()` matching DIRect.c lines 671-675:
  - Jones formula: `eps = max(|minf| * 1e-4, epsfix)`
- Added `Direct::jones()` helper returning algmethod flag (0=Original, 1=Gablonsky)
- Added 20 unit tests covering all functionality

### Files created
- direct-nlopt-rs/src/direct.rs

### Files modified
- direct-nlopt-rs/src/lib.rs (added `pub mod direct;`)
- plans/prd-direct-nlopt.json (marked preprocessing/scaling task as passes: true)

### Git commits
- `cf446cc` feat(direct): implement preprocessing, scaling, and objective evaluation

### Test results
- 81 tests passed, 0 failed (+20 new tests: preprocessing, scaling roundtrip, algebraic equivalence, evaluate feasible/infeasible, validate_inputs epsilon handling, tolerance conversion, epsilon update, jones flag, multidim scaling)
- cargo clippy clean (0 warnings)

### Notes
- The `ObjectiveFn` type alias (`dyn Fn(&[f64]) -> f64 + Send + Sync`) is used via `Arc<ObjectiveFn>` to satisfy clippy's type_complexity lint
- Roundtrip scaling test uses 1e-9 tolerance for extreme bound ranges (e.g., [-1e10, 1e10]) due to floating-point precision limits
- The `to_actual`/`to_normalized` pair is the inverse of NLOPT's in-place unscale/rescale in `dirinfcn_()` — NLOPT modifies x[] in place, but our Rust version takes separate input/output slices for safety
- Storage creation in `Direct::new()` delegates to `RectangleStorage::new()` with the same MAXFUNC/MAXDEEP formulas as NLOPT


## Iteration 6 — Implement direct.rs: Initialization matching direct_dirinit_() (2026-02-21)

### What was implemented
- Added initialization state fields to `Direct` struct matching NLOPT's DIRect.c variables:
  `minf`, `minpos`, `fmax`, `ifeasible_f`, `iinfeasible`, `actmaxdeep`, `nfev`, `nit`
- Implemented `Direct::initialize()` matching `direct_dirinit_()` (DIRsubrout.c lines 1152-1321):
  1. Calls `storage.init_lists()`, `precompute_levels(jones)`, `precompute_thirds()`
  2. Sets center of rect 1 to (0.5,...,0.5) with zero lengths
  3. Evaluates center point, handles infeasibility (flag=1 → f=INFINITY)
  4. Sets `minf`, `minpos`, `point[1]=0`, `free=2`
  5. Gets `delta = thirds[1]`, longest dims via `get_longest_dims(1)`
  6. Calls `sample_points()`, `evaluate_sample_points()`, `divide_rectangle()`
  7. Calls `insert_into_list()` to build anchor linked lists
  8. Sets `actmaxdeep = 1` (matching DIRect.c line 426)
- Implemented `Direct::sample_points()` matching `direct_dirsamplepoints_()` (DIRsubrout.c lines 870-936):
  - Allocates 2×maxi rectangle slots from free list chain
  - Copies parent center/lengths to each new rect
  - Sets ±delta offsets along each longest dimension in pairs (pos, neg)
  - Returns start of new chain; errors if free list exhausted
- Implemented `Direct::evaluate_sample_points()` matching `direct_dirsamplef_()` (DIRserial.c lines 17-150):
  - Pass 1: evaluates all 2×maxi points, tracks fmax, sets feasibility flags
  - Pass 2: updates minf/minpos for feasible points only (flag == 0.0)
  - Infeasible points get f-value = current fmax, flag = 2.0
- Implemented `Direct::divide_rectangle()` matching `direct_dirdivide_()` (DIRsubrout.c lines 944-1009):
  - Computes w = min(f+, f-) for each dimension pair
  - Sorts dimensions by w ascending (stable sort matching NLOPT's insertion sort)
  - Sets length indices: dims divided first get length incremented in all subsequent children
- Added 14 unit tests verifying:
  - nfev = 2n+1 for 1D, 2D, 3D, 5D
  - Exact center coordinates and function values
  - Exact sample point centers (±thirds[1] offsets)
  - Function values for sphere on [-5,5]^n (f = 100/9 for all samples)
  - minf, minpos, fmax, ifeasible_f, iinfeasible state
  - Length indices after divide_rectangle (e.g., [1,0] vs [1,1])
  - Anchor linked lists (depth 0 and depth 1 chains)
  - Free pointer advancement
  - actmaxdeep = 1
  - 1D initialization
  - Asymmetric bounds (Rosenbrock on [0,2]×[-1,3])
  - Jones Original (jones=0) anchor placement with sum-based levels

### Files modified
- direct-nlopt-rs/src/direct.rs (added state fields, 4 methods, 14 tests)
- plans/prd-direct-nlopt.json (marked initialization task as passes: true)
- direct-nlopt-rs/progress.txt (this entry)

### Git commits
- (pending)

### Test results
- 95 tests passed, 0 failed (+14 new initialization tests)
- cargo clippy clean (0 warnings)

### Notes
- The `actdeep = 2` set inside dirinit_ (line 1273) is dead code — overwritten by DIRect.c
  setting `actmaxdeep = 1` immediately after; our code skips the dead assignment
- Center infeasibility uses flag=1 (matching dirinit_), while sample infeasibility uses flag=2
  (matching dirsamplef_) — this inconsistency exists in NLOPT C and is faithfully reproduced
- divide_rectangle uses stable sort to match NLOPT's insertion sort behavior
- For the sphere function on [-5,5]^2, all 4 sample f-values are exactly 100/9 (symmetric),
  so the stable sort preserves dimension ordering (dim 1 before dim 2)


## Iteration 6 — Implement sample_points parallel path + force_stop (2026-02-21)

### What was implemented
- Enhanced `evaluate_sample_points()` with parallel evaluation path using rayon
  - When `options.parallel=true` and total points > 1, uses `rayon::par_iter` to evaluate
    all 2×maxi sample points concurrently
  - Collects normalized coordinates from the linked list, evaluates in parallel, then
    applies results to storage sequentially (preserving storage update order)
  - The parallel path uses `Arc<ObjectiveFn>` and inline unscaling (xs1/xs2) to avoid
    borrowing self during parallel evaluation
- Added `force_stop` field to `Direct` struct as `Arc<AtomicBool>` for thread-safe
  force-stop signaling, matching NLOPT's `force_stop` pointer in `direct_dirsamplef_()`
- Serial path now checks force_stop before and after each evaluation, matching
  DIRserial.c lines 86-92 and 124-126:
  - Before eval: if force_stop set, skip evaluation, set f=fmax and flag=-1.0
  - After eval: if force_stop set during eval, mark point with flag=-1.0
- Parallel path checks force_stop per-point via `Ordering::Relaxed` atomic load
- Added `use rayon::prelude::*` and `use std::sync::atomic::{AtomicBool, Ordering}` imports
- Verified serial path evaluation order remains identical to NLOPT C:
  positive offset first, then negative, for each dimension sequentially
- Flagging matches NLOPT C exactly: kret=0 → flag=0.0, kret≥1 → flag=2.0, kret=-1 → flag=-1.0

### Files modified
- direct-nlopt-rs/src/direct.rs (parallel evaluate_sample_points, force_stop, 16 new tests)

### Git commits
- `e2f059f` feat(direct): implement parallel sample evaluation with rayon and force_stop

### Test results
- 111 tests passed, 0 failed (+16 new tests)
- cargo clippy clean (0 warnings)
- New tests cover:
  - sample_points allocation verification (2D, 1D)
  - sample_points center offsets (2D, 1D)
  - Serial evaluation order and nfev count
  - Feasibility flag tracking (feasible, infeasible, all-infeasible)
  - fmax tracking
  - minf/minpos update
  - Parallel vs serial equivalence: sphere 2D/3D/5D, Rosenbrock 2D
  - Parallel second iteration (beyond initialization)
  - force_stop in serial and parallel modes
  - Parallel with mixed feasible/infeasible points

### Notes
- The parallel path evaluates all points concurrently but applies fmax/ifeasible updates
  sequentially, so infeasible point replacement may use a slightly stale fmax value
  compared to the serial path when some points are infeasible — this is acceptable
  because fmax is only used for placeholder values of infeasible points
- For all-feasible functions (common case), parallel and serial produce bit-identical results
- During initialization, parallel=true takes the serial path if only 1 point (never in
  practice since init always has 2n ≥ 2 points)


## Iteration 7 — Verify and Test divide_rectangle matching direct_dirdivide_() (2026-02-21)

### What was implemented
- Verified `divide_rectangle()` in direct.rs matches `direct_dirdivide_()` in DIRsubrout.c (lines 944-1009) exactly
- Analyzed the C code's two-phase approach: phase 1 computes w[j] = min(f+, f-) and builds a sorted linked list via `dirinsertlist_2__`, phase 2 extracts in sorted order via `dirsearchmin_` and sets lengths incrementally
- Confirmed Rust's `sort_by` (stable sort) matches C's insertion sort for equal w values
- Verified the key invariant: dimensions divided FIRST (smallest w) have their length propagated to MORE children — children of later-divided dimensions accumulate all earlier dimensions' length increments
- Added 9 comprehensive unit tests covering:
  - 3D rectangle division with unequal w values verifying dimension sort order
  - 2D with equal w values verifying stable sort preserves original order
  - 1D single dimension division
  - Non-zero current_length (depth > 0 divisions)
  - Parent center unchanged after division
  - 3D with only 2 dims longest (partial division)
  - w = min(f_pos, f_neg) verification with asymmetric f-values
  - End-to-end integration with sample_points + evaluate + divide
  - 5D all-dims division with full length propagation verification

### Files modified
- direct-nlopt-rs/src/direct.rs (added 9 divide_rectangle tests + test helper setup_divide_test)
- plans/prd-direct-nlopt.json (marked divide_rectangle task as passes: true)

### Git commits
- `34b7184` test(direct): add comprehensive divide_rectangle unit tests matching dirdivide_

### Test results
- cargo clippy clean

### Notes
- The incremental length propagation pattern means: children of the last-divided dimension (largest w) get ALL dimensions' lengths incremented (becoming cubes), while children of the first-divided dimension only get their own dimension incremented (remaining elongated)
- This is the expected DIRECT behavior: trisecting along the dimension with best improvement first ensures the search focuses on promising directions


## Iteration 12 — Implement Main Iteration Loop (Direct::minimize()) (2026-02-21)

### What was implemented
- Implemented `Direct::minimize()` method matching `direct_direct_()` in DIRect.c (lines 449-768)
- The main loop follows NLOPT's exact flow:
  1. `validate_inputs()` → epsilon handling, bound checks
  2. `initialize()` → center + 2n neighbors + first division
  3. Main iteration loop:
     - `PotentiallyOptimal::select()` (dirchoose_) → convex hull rectangle selection
     - `PotentiallyOptimal::double_insert()` (dirdoubleinsert_) for Jones Original (algmethod=0)
     - For each selected rectangle:
       - `get_max_deep()` for delta calculation
       - `remove_from_list_at_depth()` for general linked list removal (new method)
       - `get_longest_dims()`, `sample_points()`, `evaluate_sample_points()`
       - `divide_rectangle()`, `insert_into_list()`
     - Termination checks: volume_tol, sigma_tol, fglobal, maxfeval, maxiter, maxtime
     - `replace_infeasible()` after processing
     - Epsilon update via Jones formula
  4. Best point extraction via `to_actual(center[minpos])`
- Added `RectangleStorage::remove_from_list_at_depth()` for general linked list removal
  (the existing `remove_from_anchor()` only handled head removal; the main loop needs
  to remove non-head rects when using `dirdoubleinsert_` with Jones Original)
- Key fix: `po.select()` must receive `storage.maxdeep` (MAXDEEP constant) as the sweep
  limit, NOT `actmaxdeep` — matching DIRect.c line 455 which passes `&MAXDEEP`
- Callback support: called when a new minimum is found (`oldpos < minpos`), returns true
  to trigger force_stop
- Infeasible budget extension: when no feasible point found, budget is automatically extended
  (DIRect.c lines 678-713)
- Force-stop mechanism: atomic flag checked during evaluation and between iterations

### Files modified
- direct-nlopt-rs/src/direct.rs (added minimize() method with ~250 lines + 17 integration tests)
- direct-nlopt-rs/src/storage.rs (added remove_from_list_at_depth() method)
- plans/prd-direct-nlopt.json (marked main iteration loop as passes: true)

### Git commits
- (pending)

### Test results
- 137 tests passed, 0 failed (+17 new integration tests)
- New tests cover:
  - Sphere 1D/2D/3D/5D with GablonskyLocallyBiased
  - Sphere 2D with GablonskyOriginal (Jones, uses dirdoubleinsert_)
  - Rosenbrock 2D with both algorithm variants
  - Rastrigin 2D (multimodal)
  - MaxIter termination, MaxFeval termination, fglobal termination, VolTol termination
  - Callback force_stop, atomic force_stop
  - Asymmetric bounds, Jones epsilon update
  - Parallel vs serial comparison
  - Result field validation
- cargo clippy clean

### Notes
- The `po.select()` sweep limit was initially `actmaxdeep` which caused infinite loops
  because rects at deeper levels were never found. Fixed to use `storage.maxdeep` (MAXDEEP)
  matching the NLOPT C call in DIRect.c line 455
- The callback only fires when `oldpos < minpos` (new minimum found). For functions with
  minimum at the domain center (like sphere), the center evaluation during init finds f=0
  immediately, so minpos never changes and the callback never fires
- `nfev` may slightly exceed `max_feval` because the termination check happens at the end
  of each iteration, after all selected rects have been processed — this matches NLOPT behavior


## Iteration 13 — Verify and Complete replace_infeasible Implementation (2026-02-21)

### What was implemented
- Audited `replace_infeasible()` in storage.rs against `direct_dirreplaceinf_()` in
  NLOPT DIRsubrout.c (lines 523–643) line by line. Implementation is faithful.
- Audited `resort_list()` against `dirresortlist_()` (lines 410–513). Correct.
- Audited `isinbox_()` (lines 376–400) — Rust uses `(0..n).all(|l| a[l] <= x && x <= b[l])` which matches the C logic exactly.
- Fixed perturbation constant from `1e-6` (f64) to `1e-6_f32 as f64` to match NLOPT's
  `1e-6f` float literal (promoted to double). Ensures bit-exact fidelity.
- Verified dead code in NLOPT C (lines 619–623, unscaling x but never using it) is
  correctly omitted in Rust (xs1/xs2 params are unused).
- Verified the `f[flag] > 0.0` condition correctly re-scans both INFEASIBLE (2) and
  REPLACED (1) points on each call, matching NLOPT behavior.
- Added 5 new comprehensive unit tests for replace_infeasible:
  - `test_replace_infeasible_multiple_nearby_takes_min`: two feasible near one infeasible → min selected
  - `test_replace_infeasible_mixed_points`: multiple infeasible/feasible at various locations
  - `test_replace_infeasible_fmax_finite`: fmax finite, no nearby → max(fmax+1, f)
  - `test_replace_infeasible_previously_replaced_rescanned`: flag=1 points are re-processed
  - `test_replace_infeasible_resort_changes_anchor`: replaced point becomes new anchor when f < anchor f

### Files modified
- direct-nlopt-rs/src/storage.rs (fixed 1e-6 → 1e-6_f32 as f64 perturbation, added 5 tests)
- plans/prd-direct-nlopt.json (marked replace_infeasible task as passes: true)

### Git commits
- `47c847a` test(storage): verify and complete replace_infeasible with NLOPT fidelity

### Test results
- 142 tests passed, 0 failed (+5 new replace_infeasible tests)
- cargo clippy clean

### Notes
- The initial sidelength computation in NLOPT C (lines 565–566: `help = dirgetmaxdeep_; sidelength = thirds[help] * 2`) is dead code — immediately overwritten in the per-dimension loop. Rust correctly omits it.
- NLOPT passes `&u[1]` and `&l[1]` as c1/c2 to dirreplaceinf_, but they're only used in dead code (unscaling x, lines 619–623). Rust correctly marks xs1/xs2 as unused.
- The `1e-6f` vs `1e-6` difference is ~2.5e-14 relative — negligible but fixed for fidelity.


## Iteration 14 — Implement cdirect.rs: SGJ Red-Black Tree DIRECT (2026-02-21)

### What was implemented
- Implemented complete `cdirect.rs` module faithfully porting NLOPT's `cdirect.c` (603 lines)
- `CDirectParams` struct matching cdirect.c `params` struct with `which_diam`, `which_div`, `which_opt` from base-3 `which_alg` encoding
- `HyperRect` struct with flat `Vec<f64>` layout: `[diameter, f_value, age, centers..., widths...]` matching cdirect.c's `L=2n+3` array
- `RectKey` with lexicographic `(diameter, f_value, age, id)` ordering matching `cdirect_hyperrect_compare()`
- `rect_diameter()` with f32 rounding for both Jones (Euclidean) and Gablonsky (max-side) measures
- `function_eval()` with min tracking matching cdirect.c lines 136–144
- `divide_rect_by_key()` with both Path A (multi-dim Gablonsky: trisect all longest, sort by `min(f+,f-)`) and Path B (single-dim Jones: trisect one longest)
- `convex_hull()` implementing monotone chain algorithm matching cdirect.c lines 261–378, with vertical-line performance hack and duplicate point handling
- `divide_good_rects()` with epsilon test, DIRECT-L skip logic, randomized variant, and fallback heuristic
- `optimize_unscaled()` main loop matching cdirect.c `cdirect_unscaled()` lines 476–549
- `optimize_scaled()` rescaling wrapper matching cdirect.c `cdirect()` lines 569–603
- `CDirect` public API with `new()`, `with_callback()`, `minimize()` dispatching to scaled/unscaled
- Stopping checks in `check_stop_after_eval()`: fglobal, maxfeval, maxtime (matching FUNCTION_EVAL macro)
- Used Rust `BTreeMap<RectKey, HyperRect>` as equivalent of NLOPT's `rb_tree`
- Added `CDirect` to lib.rs public re-exports
- 24 comprehensive unit tests covering: rect_diameter, convex_hull, all algorithm variants, termination modes, edge cases

### Files created
- direct-nlopt-rs/src/cdirect.rs (new module, ~1100 lines)

### Files modified
- direct-nlopt-rs/src/lib.rs (added `pub mod cdirect` and `pub use cdirect::CDirect`)
- plans/prd-direct-nlopt.json (marked cdirect implementation as passes: true)

### Git commits
- `114645f` feat(cdirect): implement SGJ red-black tree DIRECT using BTreeMap

### Test results
- 166 tests passed, 0 failed (+24 new cdirect tests)
- All 142 existing tests still pass (no regressions)
- New tests: sphere 2D/3D/5D (DIRECT/DIRECT-L/unscaled), rosenbrock 2D, rastrigin 2D, convex hull, diameter, termination modes, callbacks, edge cases

### Notes
- Uses `BTreeMap` instead of red-black tree; semantically equivalent with guaranteed O(log n) operations
- The `f32` rounding in `rect_diameter()` is critical for grouping rectangles by diameter level
- Path A pre-evaluates function at all longest-side offsets before sorting; Path B evaluates after splitting
- The fallback heuristic (divide largest rect with smallest f when nothing qualifies) matches cdirect.c lines 442–454
- Remaining clippy warnings are about loop variable indexing style, acceptable for faithful C port


## Iteration 15 — Implement Public API Matching NLOPT's direct_optimize() Wrapper (2026-02-21)

### What was implemented
- Implemented `direct_optimize()` high-level function matching NLOPT's `direct_optimize()` in `direct_wrap.c`
  - Dispatches to Gablonsky translation (`Direct`) or SGJ re-implementation (`CDirect`) based on algorithm variant
  - Tolerance conversion (ratios → percentages) already handled internally by `Direct::validate_inputs()` and `volume_reltol_pct()` / `sigma_reltol_pct()` / `fglobal_reltol_pct()`
  - `DIRECT_UNKNOWN_FGLOBAL` handling: when fglobal is unknown, fglobal_reltol is ignored (matching NLOPT)
- Implemented `DirectBuilder` with fluent API for configuring and running optimization
  - `DirectBuilder::new(func, bounds)` creates builder with default options
  - Setter methods: `.algorithm()`, `.max_feval()`, `.max_iter()`, `.max_time()`, `.magic_eps()`, `.magic_eps_abs()`, `.volume_reltol()`, `.sigma_reltol()`, `.fglobal()`, `.parallel()`, `.options()`
  - `.with_callback()` for progress monitoring and early stopping
  - `.minimize()` dispatches to appropriate backend
- Implemented convenience functions: `minimize()`, `minimize_l()`, `minimize_randomized()`
  - `minimize()` and `minimize_l()` use DIRECT-L (SGJ cdirect, `DirectAlgorithm::LocallyBiased`)
  - `minimize_randomized()` uses DIRECT-L-RAND (`DirectAlgorithm::Randomized`)
- Verified `Display` for `DirectResult` already implemented in types.rs (from Iteration 3)
- Added 22 comprehensive API-level integration tests covering:
  - `direct_optimize()` with all algorithm variants (Gablonsky Original, Gablonsky LocallyBiased, CDirect Original/L/Unscaled)
  - Builder pattern with individual setters and bulk options
  - Callback integration with both Gablonsky and CDirect backends
  - Force-stop via callback
  - fglobal termination
  - Convenience functions (minimize, minimize_l, minimize_randomized)
  - Error handling (invalid bounds, empty bounds)
  - DIRECT_UNKNOWN_FGLOBAL default behavior
  - Display formatting
  - Dispatch consistency (Gablonsky vs CDirect produce comparable results)
- Re-exported `DirectBuilder` from crate root
- Added doc-examples for `direct_optimize()` and `DirectBuilder` (verified via doctests)

### Files modified
- direct-nlopt-rs/src/lib.rs (added DirectBuilder, direct_optimize, convenience functions, 22 tests, doc-examples)
- plans/prd-direct-nlopt.json (marked public API task as passes: true)

### Git commits
- `743e10b` feat(api): implement public API with DirectBuilder, direct_optimize, and convenience functions

### Test results
- 188 lib tests passed, 0 failed (+22 new API tests)
- 2 doc-tests passed, 0 failed (+2 new)
- Total: 190 tests passed
- No regressions from prior 166 tests

### Notes
- The Gablonsky callback only fires when `oldpos < minpos` (new minimum found at higher storage index), which can miss updates when free-list recycling produces lower indices. CDirect always calls the callback per iteration.
- Pre-existing clippy warnings (loop indexing style) remain; no new warnings introduced.
- The builder pattern uses `Box<ObjectiveFn>` and `Box<CallbackFn>` type aliases to satisfy clippy's type_complexity lint.


## Iteration 16 — Create C Compilation Test Harness for NLOPT Comparison (2026-02-21)

### What was implemented
- Created build.rs that optionally compiles the NLOPT C DIRECT source files (DIRect.c, DIRsubrout.c, DIRserial.c, direct_wrap.c) using the cc crate
- Created minimal header shims (nlopt-shim/) to satisfy NLOPT C dependencies without compiling the full NLOPT library:
  - nlopt_config.h: platform-specific defines (HAVE_GETTIMEOFDAY, THREADLOCAL, etc.)
  - nlopt.h: minimal typedefs needed by nlopt-util.h
  - nlopt_util_shim.c: provides nlopt_seconds(), nlopt_stop_time_(), nlopt_isinf/isnan/isfinite/istiny
  - nlopt-util.h: copied from NLOPT source (used by direct-internal.h)
- Created tests/nlopt_ffi.rs: Rust FFI wrapper with safe NloptDirectRunner struct and C objective function callbacks
  - Defines DirectAlgorithmC and DirectReturnCodeC enums matching NLOPT's C enums
  - Provides sphere_c, rosenbrock_c, rastrigin_c as extern "C" objective functions
  - 4 standalone NLOPT C tests (sphere/rosenbrock × Original/Gablonsky)
  - 2 comparison tests that run NLOPT C and Rust side-by-side and verify both find correct minima
- Created tests/test_nlopt_c.c: standalone C test program for direct compilation and testing
- Feature-gated everything behind 'nlopt-compare' feature flag:
  - build.rs only compiles C code when feature is active
  - tests/nlopt_ffi.rs uses #![cfg(feature = "nlopt-compare")] to skip without feature
  - Added cc crate as optional build-dependency in Cargo.toml
- Verified: NLOPT C produces correct results (sphere minf=0, rosenbrock minf≈1.8e-19)
- Verified: Rust implementation matches NLOPT C results closely (bit-exact for sphere, near-identical for rosenbrock)

### Files created
- direct-nlopt-rs/build.rs
- direct-nlopt-rs/nlopt-shim/nlopt_config.h
- direct-nlopt-rs/nlopt-shim/nlopt.h
- direct-nlopt-rs/nlopt-shim/nlopt_util_shim.c
- direct-nlopt-rs/nlopt-shim/nlopt-util.h (copied from nlopt/src/util/)
- direct-nlopt-rs/tests/nlopt_ffi.rs
- direct-nlopt-rs/tests/test_nlopt_c.c

### Files modified
- direct-nlopt-rs/Cargo.toml (added cc as optional build-dep, nlopt-compare feature)
- plans/prd-direct-nlopt.json (marked test-foundation as passes: true)

### Git commits
- `d1474f4` test(foundation): create C compilation test harness for NLOPT comparison testing

### Test results
- 6 new nlopt_ffi tests passed (with --features nlopt-compare)
- 2 doc-tests passed
- Total with feature: 196 passed, 0 failed (+6 new tests)

### Notes
- The standalone C test program (tests/test_nlopt_c.c) could not be compiled directly due to macOS permission restrictions, but the cc crate compilation in build.rs works fine
- NLOPT C sphere 2D finds exact 0.0 minimum; Rust also finds exact 0.0 — bit-identical
- NLOPT C rosenbrock 2D GABLONSKY: x=[0.9999999997132019, 0.9999999993945377], minf=1.84e-19
- Rust rosenbrock 2D GABLONSKY: x=[0.9999999997132014, 0.9999999993945374], minf=1.84e-19 — nearly identical (last digits differ slightly)
- This harness enables all subsequent comparison tests to verify Rust vs C equivalence


## Iteration 17 — Comparative Unit Tests for Scaling/Unscaling (2026-02-21)

### What was implemented
- Created comparative unit tests that call NLOPT C `direct_dirpreprc_()` and `direct_dirinfcn_()` via FFI
  and verify that the Rust implementation produces identical results
- Added FFI declarations for `direct_dirpreprc_` (DIRsubrout.c:1403) and `direct_dirinfcn_` (DIRsubrout.c:1048)
  which were already compiled via build.rs but not previously exposed in test code
- Tests cover all PRD-specified scenarios:
  - Symmetric bounds [-5,5]: verified xs1=10, xs2=-0.5 in both C and Rust (bit-identical)
  - Asymmetric bounds [2,10]: verified xs1=8, xs2=0.25 in both C and Rust (bit-identical)
  - Near-zero bounds [0,1]: verified xs1=1, xs2=0 in both C and Rust (bit-identical)
  - Multi-dimensional bounds (3D): verified all xs1/xs2 values match
  - Invalid bounds: verified both C (oops=1) and Rust (Err) reject u<=l
  - Extreme bounds: [-1e10,1e10] and [0,1e-10] verified identical
- Roundtrip tests verify C's dirinfcn_ rescaling: x_norm → unscale → evaluate → rescale → x_norm
  matches Rust's to_actual/to_normalized roundtrip for 12 test configurations
- Algebraic equivalence test: verified (x+xs2)*xs1 == x*xs1+l using C-computed xs1/xs2
  for 6 bounds configurations × 5 normalized x values
- Bit-identical f-value comparison: C dirinfcn_(sphere) vs Rust evaluate(sphere) for
  6 bounds configurations × multiple sample points (1D grid, 2D grid, 3D corners)

### Files created
- tests/test_scaling_compare.rs (13 comparative unit tests)

### Files modified
- plans/prd-direct-nlopt.json (marked scaling/unscaling test-unit as passes: true)

### Git commits
- `95fdace` test(direct): add comparative scaling/unscaling tests vs NLOPT C dirpreprc_ and dirinfcn_

### Test results
- 209 tests passed, 0 failed (+13 new tests)
  - 188 lib tests, 6 nlopt_ffi tests, 13 scaling_compare tests, 2 doc-tests
- No regressions

### Notes
- All 13 C-vs-Rust comparisons produce bit-identical results for xs1, xs2, and f-values
- The C function uses Fortran-style 1-based indexing via pointer decrements; the FFI
  wrapper handles this transparently by passing standard 0-based Rust arrays
- The C dirinfcn_ mutates x in-place (unscale, call, rescale), verified via roundtrip test


## Iteration 18 — Comparative Unit Tests for Level Computation (dirgetlevel_) (2026-02-21)

### What was implemented
- Created comparative unit tests for `direct_dirgetlevel_()` verifying Rust `get_level()`
  produces identical results to the NLOPT C function for both algorithm variants
- Jones Original (jones=0) tests: the level formula `k*n + (n-p)` when k==help, or
  `k*n + p` when k!=help, where help=length[dim0], k=min(all lengths), p=count(dims==help)
- Gablonsky (jones=1) tests: level = min(all length indices), equivalent to get_max_deep()
- Test cases cover all PRD requirements:
  - Uniform lengths [0,0,0]: both variants produce 0
  - Mixed [1,0,1]: jones=0→2, jones=1→0
  - All equal [2,2,2]: jones=0→6, jones=1→2
  - Asymmetric [0,1,2,3]: jones=0→3, jones=1→0
  - 1D edge case: [0]→0, [3]→3, [5]→5 for both variants
  - 2D cases: 6 configurations testing both k==help and k!=help branches
  - 5D cases: 4 configurations including mixed high-dimensional lengths
  - Partial match cases: [2,2,1], [1,2,2], [3,1,3,1] testing p counting
- Cross-validation test: 29 length configurations × 2 jones values = 58 comparisons
- Known-value verification: hand-computed expected values checked against both C and Rust
- Multi-position test: rectangles at positions 1, 5, and 10 verify indexing correctness
- FFI calls `direct_dirgetlevel_()` from DIRsubrout.c with proper Fortran-style 1-based
  pointer arithmetic handling

### Files created
- tests/test_level_compare.rs (19 comparative unit tests)

### Files modified
- plans/prd-direct-nlopt.json (marked level computation test-unit as passes: true)

### Git commits
- `b5d74f8` test(storage): add comparative level computation tests vs NLOPT C dirgetlevel_

### Test results
- 228 tests passed, 0 failed (+19 new tests)
  - 188 lib tests, 6 nlopt_ffi tests, 19 level_compare tests, 13 scaling_compare tests, 2 doc-tests
- No regressions

### Notes
- All 19 tests produce identical results between C and Rust implementations
- The C code uses Fortran-style 1-based column-major indexing via pointer decrement:
  `length -= (1 + n)` then accesses `length[dim_1based + pos_1based * n]`,
  which maps to 0-based `length[dim_0 + pos_0 * n]` matching Rust's layout
- Jones Original (jones=0) level computation is more complex: it tracks both
  the minimum length (k) and the count of dimensions equal to the first dimension's
  length (p), producing a finer-grained level that distinguishes rectangle shapes
- Gablonsky (jones=1) simply returns min(all lengths), same as get_max_deep()


## Iteration 19 — Comparative Unit Tests for thirds[] and levels[] Precomputation (2026-02-21)

### What was implemented
- Created comparative unit tests verifying bit-identical output between Rust `precompute_thirds()` / `precompute_levels()` and the NLOPT C computation from `direct_dirinit_()` (DIRsubrout.c lines 1208-1243)
- Added C shim helper functions `nlopt_shim_precompute_thirds()` and `nlopt_shim_precompute_levels()` to nlopt-shim/nlopt_util_shim.c, extracting the exact computation loops from `direct_dirinit_()`
- Tests verify thirds[k] = 1/3^k for k=0..50 with bit-exact comparison (using `to_bits()`)
- Tests verify levels[] for both jones=0 (Jones Original) and jones=1 (Gablonsky DIRECT-L)
- Tested with n=2, 3, 5 dimensions and maxdeep=50
- Verified Gablonsky levels are dimension-independent and identical to thirds
- Verified Jones Original levels depend on n and follow w[j] = sqrt(n - j + j/9) * 0.5 formula
- Added monotonicity and positivity property tests

### Files created
- direct-nlopt-rs/tests/test_thirds_levels_compare.rs (21 tests)

### Files modified
- direct-nlopt-rs/nlopt-shim/nlopt_util_shim.c (added thirds/levels precomputation helpers)
- plans/prd-direct-nlopt.json (marked thirds/levels precomputation tests as passes: true)

### Git commits
- `8a9372d` test(storage): add comparative thirds/levels precomputation tests vs NLOPT C
  - 188 lib tests, 6 nlopt_ffi tests, 19 level_compare tests, 13 scaling_compare tests, 21 thirds_levels_compare tests, 2 doc-tests
- No regressions

### Notes
- All 21 tests use bit-exact comparison (`to_bits()`) confirming the Rust implementation produces IEEE 754 identical results to the C code
- For jones=0 (Jones Original), only indices 0..(maxdeep/n)*n are populated — unfilled entries remain zero
- For jones=1 (Gablonsky), the levels array is identical to thirds and is dimension-independent
- The C shim approach avoids the complexity of calling full `direct_dirinit_()` which requires objective function setup


## Iteration 20 — Comparative Unit Tests for get_longest_dims (dirget_i__) (2026-02-21)

### What was implemented
- Created 15 comparative unit tests verifying Rust `RectangleStorage::get_longest_dims()` matches NLOPT C `direct_dirget_i__()` exactly
- FFI wrapper calls NLOPT C function compiled via build.rs with `nlopt-compare` feature
- Verified C function's Fortran-style 1-based column-major indexing matches Rust's row-major layout
- Test scenarios from PRD:
  - [0,0,0]: all dims longest → maxi=3, arrayi=[1,2,3] ✓
  - [1,0,0]: dims 2,3 longest → maxi=2, arrayi=[2,3] ✓
  - [0,1,2]: only dim 1 longest → maxi=1, arrayi=[1] ✓
  - [2,2,1,1]: dims 3,4 longest → maxi=2, arrayi=[3,4] ✓
- Additional coverage: 1D cases, 2D variations, 5D mixed/equal/single, large length values, different rect positions, comprehensive sweep of 16 configurations

### Files created
- direct-nlopt-rs/tests/test_get_longest_dims_compare.rs

### Files modified
- plans/prd-direct-nlopt.json (marked get_longest_dims test-unit as passes: true)

### Git commits
- `30414fd` test(storage): add comparative unit tests for get_longest_dims (dirget_i__)

### Test results
- 2 doc-tests passed
- No regressions

### Notes
- NLOPT C uses Fortran-translated indexing: `--arrayi` pointer adjustment for 1-based writes, column-major length layout with `length -= (1 + n)` offset
- Rust implementation uses 0-based internal storage but returns 1-based dimension indices (matching NLOPT convention)
- Both implementations find minimum length index first, then collect all dimensions with that minimum — identical logic

## Iteration 21 — Comparative Unit Tests for Linked List Operations (dirinitlist_, dirinsertlist_) (2026-02-21)

### What was implemented
- Created `tests/test_linked_list_compare.rs` with 10 comparative tests calling both NLOPT C FFI and Rust implementations
- Tests cover: init_lists, sorted insertion at same level, insertion at different depths, removal, ascending order walk, dirinit-style insertion, jones=0 level computation, 3D insertion, equal f-value tie-breaking, and large batch stress test
- Created CStorage helper struct that mirrors NLOPT's C memory layout with 1-based indexing via pointer adjustment conventions
- FFI bindings for direct_dirinitlist_(), direct_dirinsertlist_(), and direct_dirgetlevel_()

### PRD item completed
- "Create comparative unit tests for linked list operations (dirinitlist_, dirinsertlist_)" → passes: true

### Test results
- All 10 new linked list comparative tests pass
- Full test suite: 188 unit tests + all integration tests pass, no regressions
- Clippy: no new warnings

### Notes
- NLOPT C uses `--point` adjustment giving maxfunc usable slots (1..maxfunc), while Rust uses maxfunc-1 slots (1..maxfunc-1) — a 1-slot difference that is algorithmically negligible
- init_lists test compares behavioral equivalence (valid free chain structure) rather than bit-exact raw memory
- C `direct_dirinsertlist_()` uses `f -= 3` (Fortran 1-based column offset), `--point`, `++anchor`, `length -= (1 + n)` pointer adjustments
- CStorage helper provides `set_f(idx, val, flag)`, `get_point()`, `set_point()`, `get_anchor()`, `alloc_rect()`, `walk_list()` methods mapping between 1-based C conventions and raw 0-based arrays


## Iteration 22 — Comparative Unit Tests for PotentiallyOptimal::select() (dirchoose_) (2026-02-21)

### What was implemented
- Created comprehensive comparative unit tests verifying Rust PotentiallyOptimal::select() against NLOPT C direct_dirchoose_() and PotentiallyOptimal::double_insert() against direct_dirdoubleinsert_()
- 19 tests across 12 scenarios covering both Gablonsky (jones=1) and Jones Original (jones=0) variants:
  - Scenario 1: All rects at different levels with monotonically decreasing f → all selected (both variants)
  - Scenario 2: One rect above convex hull → correctly excluded (both variants)
  - Scenario 3: Multiple rects at same level → only anchor (lowest f) considered (both variants)
  - Scenario 4: Epsilon test eliminates hull-point rects — tested with eps_rel and eps_abs
  - Scenario 5: Empty levels / gaps in depth distribution (both variants, including n=3)
  - Scenario 6: All infeasible → picks first non-empty anchor
  - Scenario 7: Mixed feasible/infeasible with infeasible anchor at depth -1
  - Scenario 8: Complex hull with 6 rects (both variants)
  - Scenario 9: Non-cube rectangles testing Jones Original level computation
  - Scenario 10: Single rect trivially selected
  - Scenario 11: Deeper rect with higher f → eliminated by slope ≤ 0
  - Scenario 12: Boundary epsilon values (zero and large epsilon)
  - dirdoubleinsert test: 3 tied rects (within 1e-13) + 1 untied at same depth
- Implemented manual sorted insertion helpers for both C and Rust storages to set up known configurations without using the pair-insert division pattern
- Verified NLOPT C uses `levels` array (not `thirds`) when calling dirchoose_ — confirmed by DIRect.c line 455
- All C FFI calls use correct parameter adjustments matching NLOPT's Fortran→C indexing conventions

### Files created
- direct-nlopt-rs/tests/test_dirchoose_compare.rs

### Files modified
- plans/prd-direct-nlopt.json (marked dirchoose_ test task as passes: true)

### Git commits
- `c06aabe` test(storage): add comparative unit tests for PotentiallyOptimal::select() and double_insert() vs NLOPT C dirchoose_ and dirdoubleinsert_

### Test results
- 294 tests passed, 0 failed (+20 new tests: 19 dirchoose + 1 dirdoubleinsert)
- All existing tests continue to pass without regression

### Notes
- NLOPT C's dirchoose_ parameter named `thirds` actually receives the `levels` array from DIRect.c (confirmed at line 455)
- The convex hull elimination logic matches exactly between Rust and C for all tested scenarios
- The epsilon test threshold formula min(minf - eps_rel*|minf|, minf - eps_abs) is faithfully replicated
- Jones Original level computation with non-cube rects (k*n + p formula) verified working correctly
- The infeasible anchor (depth -1 / anchor[0]) handling is correctly appended after hull elimination


## Iteration 23 — Comparative Unit Tests for divide_rectangle (dirdivide_) (2026-02-21)

### What was implemented
- Created comparative unit tests verifying that Rust `Direct::divide_rectangle()` produces identical
  length arrays to NLOPT C `direct_dirdivide_()` in DIRsubrout.c lines 944-1009
- Tests call both the C function via FFI and the Rust function with identical inputs, then compare
  all resulting length arrays (parent + all pos/neg children)
- 17 tests covering:
  - 3D with unequal w-values verifying dimension sort by min(f+, f-)
  - 2D with equal w-values verifying stable sort preserves original order
  - 1D single-dimension division
  - Nonzero current_length (depth > 0) verifying length increment is current_length + 1
  - Parent having all divided dims set to new_len
  - 3D with only 2 of 3 dims longest (partial division)
  - w = min(f_pos, f_neg) with large positive/small negative asymmetry
  - 5D with all dims verifying complete sort order and length cascade
  - Deep level (current_length=5) division
  - Degenerate case: all same f-values
  - Negative f-values
  - Mixed parent lengths (non-uniform)
  - Non-sequential arrayi order (reversed dims)
  - Tiny f-value differences testing sort stability
  - Comprehensive sweep of 1D/2D/3D/4D scenarios
  - Explicit cascade pattern verification (first-sorted dims set in ALL subsequent children)
  - End-to-end integrated test (initialize → sample → evaluate → divide)
- All tests confirm bit-exact match between NLOPT C and Rust implementations

### Files created
- direct-nlopt-rs/tests/test_divide_compare.rs

### Files modified
- plans/prd-direct-nlopt.json (marked divide_rectangle test-unit as passes: true)

### Git commits
- `5f6443a` test(direct): add comparative unit tests for divide_rectangle (dirdivide_)

### Test results
- No regressions in existing tests

### Notes
- The C FFI wrapper carefully handles NLOPT's Fortran-style 1-based column-major indexing with
  parameter adjustments (f -= 3, --point, --arrayi, length -= (1+n))
- The internal sorting uses dirinsertlist_2__ (sorted insertion) and dirsearchmin_ (extract minimum),
  which together implement insertion sort by w-value — confirmed identical to Rust's sort_by approach
- The length cascade pattern is faithfully replicated: dimensions divided first (lower w) get their
  length set in ALL children from that sort position onward


## Iteration 24 — Comparative unit tests for cdirect convex_hull() and rect_diameter() (2026-02-21)

### What was implemented
- Created 23 comparative unit tests verifying Rust CDirect rect_diameter() and convex_hull() 
  produce identical results to NLOPT C cdirect.c algorithms
- Added standalone C shim functions to nlopt_util_shim.c:
  - `nlopt_shim_rect_diameter()`: replicates cdirect.c lines 94–112 exactly, including
    the critical f32 rounding performance hack
  - `nlopt_shim_convex_hull()`: replicates cdirect.c lines 261–378 monotone chain algorithm
    using sorted arrays instead of red-black tree (same algorithm, simpler data structure)
- rect_diameter tests (8 tests):
  - Jones (Euclidean) measure with various widths (1D through 10D)
  - Gablonsky (max-side) measure with various widths
  - f32 rounding verification (diameter should roundtrip through f32)
  - Jones vs Gablonsky differ for non-cubic and cubic rectangles
  - DIRECT subdivision sequence verification (diameter non-increasing)
  - Edge cases: very small widths (1e-8), very large widths (1e6), 1D
- convex_hull tests (15 tests):
  - Monotonically decreasing f values (all points on hull)
  - One point above hull (excluded correctly)
  - Single point, two points, empty input
  - Same diameter (vertical line) handling
  - Duplicate diameters with vertical lines
  - Collinear points (cross product >= 0 boundary check)
  - Duplicate endpoints with allow_dups=true and false
  - Complex scenario with points above and below hull
  - Realistic DIRECT diameters from simulated [-5,5]^2 optimization
  - Many points at same diameter (stress test)
  - V-shaped hull (f decreases then increases)

### Files created
- direct-nlopt-rs/tests/test_cdirect_hull_compare.rs

### Files modified
- direct-nlopt-rs/nlopt-shim/nlopt_util_shim.c (added rect_diameter and convex_hull shim functions)
- plans/prd-direct-nlopt.json (marked cdirect convex_hull/rect_diameter test-unit task as passes: true)

### Git commits
- `4b0656b` test(cdirect): add comparative unit tests for convex_hull() and rect_diameter() vs NLOPT C

### Test results
- All existing tests continue to pass
- Clippy clean (only pre-existing warnings)

### Notes
- Integration tests using FFI to C shim functions require a `use direct_nlopt::...` import
  to force Cargo to link the native C library from the rlib; without this, the linker
  can't find the C symbols (they are bundled in the rlib but only included when the crate
  is actually referenced)
- The C shim convex_hull uses pre-sorted arrays instead of rb_tree to avoid compiling
  the full NLOPT redblack.c infrastructure; this tests the same algorithm faithfully
- Gablonsky diameter does NOT decrease when dividing one dimension of a square rectangle
  (max side stays the same), so the subdivision test uses >= instead of >

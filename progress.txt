# Progress Log - direct-nlopt-rs: NLOPT DIRECT algorithm family in Rust


## Iteration 0 — Project Setup & Ralph Initialization (2026-02-21)

### What was implemented
- Initialized git repository in `direct-nlopt-rs/` with basic Rust project structure
- Created feature branch `feature/nlopt-direct-faithful-implementation` for all ralph-driven changes
- Created Cargo.toml with dependencies: rayon, parking_lot, thiserror, ordered-float, libc, etc.
- Created src/lib.rs crate root with module declarations
- Created src/error.rs with DirectReturnCode and DirectError types matching NLOPT's direct_return_code enum
- Created benches/benchmarks.rs placeholder for Criterion benchmarks
- Created .gitignore
- Thoroughly analyzed both NLOPT DIRECT implementations:
  - Gablonsky Fortran→C translation (DIRect.c, DIRsubrout.c, DIRserial.c, direct_wrap.c): ~2600 lines
  - SGJ C re-implementation (cdirect.c, hybrid.c): ~950 lines
- Generated permanent context prompt (prompts/direct-nlopt-rs.txt) with full project context,
  NLOPT C → Rust function mapping tables for both implementations, data structure correspondence,
  algorithm flow documentation, parallelization strategy, and task instructions
- Generated PRD plan (plans/prd-direct-nlopt.json) with 54 ordered tasks across 12 categories:
  analysis (5), implementation (10), test-foundation (1), test-unit (7), test-integration (11),
  parallelization (4), performance (3), ffi (1), edge-cases (3), test-regression (3), documentation (2)
- Verified Rust project builds successfully

### Files created
- direct-nlopt-rs/.gitignore
- direct-nlopt-rs/Cargo.toml
- direct-nlopt-rs/src/lib.rs
- direct-nlopt-rs/src/error.rs
- direct-nlopt-rs/benches/benchmarks.rs
- prompts/direct-nlopt-rs.txt (permanent context prompt for ralph)
- plans/prd-direct-nlopt.json (54-item PRD plan)

### Git commits
- `df12538` chore(init): initialize direct-nlopt-rs project with basic structure

### Test results
- Project builds successfully (cargo build)
- No tests yet (baseline)

### Notes
- Two NLOPT DIRECT codepaths must be ported: Gablonsky translation AND SGJ re-implementation
- The Gablonsky translation uses SoA + linked lists (similar to scipy port in direct-rs/)
- The SGJ re-implementation uses red-black trees (cleaner but different data structure)
- Both codepaths must produce identical results to their NLOPT C counterparts
- Parallelization via rayon should be added at function evaluation points
- The venv/ folder has Python 3.12 for any comparison scripts needed


## Iteration 1 — Analysis of DIRect.c Main Loop and Memory Layout (2026-02-21)

### What was implemented
- Thoroughly analyzed `nlopt/src/algs/direct/DIRect.c` line by line, documenting:
  - Complete `direct_direct_()` function: signature, all parameters, return codes
  - Full variable map: every dynamically allocated array (`c__`, `f`, `length`, `point`,
    `anchor`, `s`, `thirds`, `levels`, `w`, `oldl`, `oldu`, `list2`, `arrayi`) with sizes,
    indexing conventions (1-based Fortran heritage), and purpose
  - All scalar variables: `jones`, `ifree`, `minpos`, `fmax`, `numfunc`, `actdeep`,
    `actmaxdeep`, `maxi`, `maxpos`, `ifeasiblef`, `iinfesiblef`, `iepschange`, etc.
  - Memory allocation scheme: `MAXFUNC = maxf + 1000 + maxf/2`, `MAXDEEP = MAXFUNC/5`,
    `MAXDIV = 5000` constant
  - SGJ's transposition of arrays from Fortran column-major to C row-major layout
  - Initialization sequence: `dirheader_()` → `dirinitlist_()` → `dirpreprc_()` → `dirinit_()`
  - Main iteration loop: `dirchoose_()` → `dirdoubleinsert_()` (Original only) →
    for-each-selected-rect: remove → `dirget_i_()` → `dirsamplepoints_()` →
    `dirsamplef_()` → `dirdivide_()` → `dirinsertlist_()`
  - Termination checks in exact order: volume_tol → sigma_tol → fglobal → replace_inf →
    epsilon update → budget increase → maxfeval
  - Epsilon update logic: fixed when eps>0 (`iepschange=0`), Jones formula when eps<0
    (`iepschange=1`, `eps = max(|minf|*1e-4, epsfix)`)
  - Key quirks: bounds modified in-place by `dirpreprc_()`, volume check uses jones=0,
    budget elasticity for infeasible problems, MAXDIV=5000 limitation
- Created detailed pseudocode control flow diagram

### Files created
- direct-nlopt-rs/analysis/gablonsky_analysis.md

### Files modified
- plans/prd-direct-nlopt.json (marked first analysis item as passes: true)

### Git commits
- `ad0897f` docs(analysis): analyze DIRect.c main loop, memory layout, and control flow

### Test results
- N/A (analysis-only task, no code changes)

### Notes
- The 1-based indexing permeates the entire codebase and must be carefully handled in Rust
- `l` and `u` arrays are destructively overwritten by `dirpreprc_()` — Rust impl should
  store scaling coefficients separately to avoid this confusing pattern
- Volume tolerance check always uses jones=0 regardless of algorithm — potential intentional
  design or bug; Rust impl should match this exactly for faithfulness
- The `s` array (selected rectangles) has a hardcoded limit of MAXDIV=5000 — only relevant
  for DIRECT_ORIGINAL with `dirdoubleinsert_()`


## Iteration 2 — Analysis of DIRsubrout.c Subroutines (2026-02-21)

### What was implemented
- Thoroughly analyzed `nlopt/src/algs/direct/DIRsubrout.c` (1595 lines) function-by-function:
  - `direct_dirgetlevel_()`: Level computation for both algmethod variants. Jones Original
    returns min(length[i]), Gablonsky returns k*n+p encoding both min index and count.
  - `direct_dirchoose_()`: Potentially optimal rectangle selection via pairwise slope-based
    convex hull sweep (not monotone chain). Collects anchor heads per depth, eliminates
    candidates above hull or failing epsilon test. Special handling when no feasible point
    exists (selects only one rect).
  - `direct_dirdoubleinsert_()`: Jones Original only — walks linked lists at each selected
    rect's depth level to find additional rects with f-value within 1e-13 tolerance.
  - `direct_dirgetmaxdeep_()`: Returns min(length[i]) across all dimensions — the "depth"
    of a rectangle (identical to dirgetlevel_ with jones=1).
  - `direct_dirget_i__()`: Finds all dimensions with the minimum length index (longest
    sides). Returns dimension indices and count in arrayi/maxi.
  - `direct_dirsamplepoints_()`: Allocates 2*maxi new rectangle slots from free list,
    copies parent center/lengths, then offsets center coordinates ± delta along each
    divided dimension.
  - `direct_dirdivide_()`: Sorts dimensions by min(f+,f-) using insertion sort
    (dirinsertlist_2__), then trisects in sorted order. Critical detail: dims divided
    first get length incremented in ALL subsequent children.
  - `direct_dirinsertlist_()`: Inserts 2*maxi+1 rectangles (maxi child pairs + parent)
    into depth-indexed anchor lists maintaining f-value sorted order. Handles 6 ordering
    cases for each pair vs existing anchor.
  - `direct_dirreplaceinf_()`: For each infeasible rect, computes bounding box from side
    lengths, searches for nearby feasible points, replaces f-value with min nearby + 1e-6
    perturbation, re-sorts affected lists. Uses isinbox_() helper.
  - `direct_dirinfcn_()`: Unscale x from [0,1]^n to [l,u] via (x+xs2)*xs1, call user
    function, rescale back. Thread-unsafe (modifies x in place).
  - `direct_dirpreprc_()`: Compute scaling: xs1=u-l, xs2=l/(u-l). Validates u>l.
  - `direct_dirheader_()`: Input validation, epsilon sign handling (negative → dynamic
    Jones update), bounds checking, capacity check.
  - `direct_dirinit_()`: Full initialization — precompute thirds[]/levels[], evaluate
    center (0.5,...,0.5), sample 2n neighbors, divide first rectangle, insert into lists.
    Total evals: 2n+1.
  - `direct_dirinitlist_()`: Initialize anchors to 0, f-values to 0, point[] as free
    list chain 1→2→...→MAXFUNC→0, free=1.
  - `direct_dirsummary_()`: Final logging (no algorithmic logic).
- Documented 5 private helper functions: dirinsert_(), dirinsertlist_2__(),
  dirsearchmin_(), isinbox_(), dirresortlist_()
- Created complete function call graph showing all caller/callee relationships

### Files created
- direct-nlopt-rs/analysis/dirsubrout_analysis.md

### Files modified
- plans/prd-direct-nlopt.json (marked second analysis item as passes: true)

### Git commits
- `ac296ab` docs(analysis): analyze DIRsubrout.c subroutines function-by-function

### Test results
- N/A (analysis-only task, no code changes)

### Notes
- The `dirgetlevel_()` `p` variable counts dimensions matching `help` (dim 1's value),
  NOT the minimum `k`. This subtlety is critical for correct Gablonsky level computation.
- `dirinfcn_()` modifies `x` in-place for unscaling/rescaling — the Rust port must use a
  separate scratch buffer for thread safety.
- `dirreplaceinf_()` line 620-621 computes `x[l] = c[l,i]*c1[l] + c[l,i]*c2[l]` which
  appears to be dead code (result stored in x but never used after).
- `dirdoubleinsert_()` uses 1e-13 tolerance for "equal value" — this is hardcoded.
- The `levels[]` array has different structure depending on jones: 2D for jones=0
  (Gablonsky), 1D for jones=1 (Jones Original).

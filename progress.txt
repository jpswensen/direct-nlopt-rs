# Progress Log - direct-nlopt-rs: NLOPT DIRECT algorithm family in Rust


## Iteration 0 — Project Setup & Ralph Initialization (2026-02-21)

### What was implemented
- Initialized git repository in `direct-nlopt-rs/` with basic Rust project structure
- Created feature branch `feature/nlopt-direct-faithful-implementation` for all ralph-driven changes
- Created Cargo.toml with dependencies: rayon, parking_lot, thiserror, ordered-float, libc, etc.
- Created src/lib.rs crate root with module declarations
- Created src/error.rs with DirectReturnCode and DirectError types matching NLOPT's direct_return_code enum
- Created benches/benchmarks.rs placeholder for Criterion benchmarks
- Created .gitignore
- Thoroughly analyzed both NLOPT DIRECT implementations:
  - Gablonsky Fortran→C translation (DIRect.c, DIRsubrout.c, DIRserial.c, direct_wrap.c): ~2600 lines
  - SGJ C re-implementation (cdirect.c, hybrid.c): ~950 lines
- Generated permanent context prompt (prompts/direct-nlopt-rs.txt) with full project context,
  NLOPT C → Rust function mapping tables for both implementations, data structure correspondence,
  algorithm flow documentation, parallelization strategy, and task instructions
- Generated PRD plan (plans/prd-direct-nlopt.json) with 54 ordered tasks across 12 categories:
  analysis (5), implementation (10), test-foundation (1), test-unit (7), test-integration (11),
  parallelization (4), performance (3), ffi (1), edge-cases (3), test-regression (3), documentation (2)
- Verified Rust project builds successfully

### Files created
- direct-nlopt-rs/.gitignore
- direct-nlopt-rs/Cargo.toml
- direct-nlopt-rs/src/lib.rs
- direct-nlopt-rs/src/error.rs
- direct-nlopt-rs/benches/benchmarks.rs
- prompts/direct-nlopt-rs.txt (permanent context prompt for ralph)
- plans/prd-direct-nlopt.json (54-item PRD plan)

### Git commits
- `df12538` chore(init): initialize direct-nlopt-rs project with basic structure

### Test results
- Project builds successfully (cargo build)
- No tests yet (baseline)

### Notes
- Two NLOPT DIRECT codepaths must be ported: Gablonsky translation AND SGJ re-implementation
- The Gablonsky translation uses SoA + linked lists (similar to scipy port in direct-rs/)
- The SGJ re-implementation uses red-black trees (cleaner but different data structure)
- Both codepaths must produce identical results to their NLOPT C counterparts
- Parallelization via rayon should be added at function evaluation points
- The venv/ folder has Python 3.12 for any comparison scripts needed


## Iteration 1 — Analysis of DIRect.c Main Loop and Memory Layout (2026-02-21)

### What was implemented
- Thoroughly analyzed `nlopt/src/algs/direct/DIRect.c` line by line, documenting:
  - Complete `direct_direct_()` function: signature, all parameters, return codes
  - Full variable map: every dynamically allocated array (`c__`, `f`, `length`, `point`,
    `anchor`, `s`, `thirds`, `levels`, `w`, `oldl`, `oldu`, `list2`, `arrayi`) with sizes,
    indexing conventions (1-based Fortran heritage), and purpose
  - All scalar variables: `jones`, `ifree`, `minpos`, `fmax`, `numfunc`, `actdeep`,
    `actmaxdeep`, `maxi`, `maxpos`, `ifeasiblef`, `iinfesiblef`, `iepschange`, etc.
  - Memory allocation scheme: `MAXFUNC = maxf + 1000 + maxf/2`, `MAXDEEP = MAXFUNC/5`,
    `MAXDIV = 5000` constant
  - SGJ's transposition of arrays from Fortran column-major to C row-major layout
  - Initialization sequence: `dirheader_()` → `dirinitlist_()` → `dirpreprc_()` → `dirinit_()`
  - Main iteration loop: `dirchoose_()` → `dirdoubleinsert_()` (Original only) →
    for-each-selected-rect: remove → `dirget_i_()` → `dirsamplepoints_()` →
    `dirsamplef_()` → `dirdivide_()` → `dirinsertlist_()`
  - Termination checks in exact order: volume_tol → sigma_tol → fglobal → replace_inf →
    epsilon update → budget increase → maxfeval
  - Epsilon update logic: fixed when eps>0 (`iepschange=0`), Jones formula when eps<0
    (`iepschange=1`, `eps = max(|minf|*1e-4, epsfix)`)
  - Key quirks: bounds modified in-place by `dirpreprc_()`, volume check uses jones=0,
    budget elasticity for infeasible problems, MAXDIV=5000 limitation
- Created detailed pseudocode control flow diagram

### Files created
- direct-nlopt-rs/analysis/gablonsky_analysis.md

### Files modified
- plans/prd-direct-nlopt.json (marked first analysis item as passes: true)

### Git commits
- `ad0897f` docs(analysis): analyze DIRect.c main loop, memory layout, and control flow

### Test results
- N/A (analysis-only task, no code changes)

### Notes
- The 1-based indexing permeates the entire codebase and must be carefully handled in Rust
- `l` and `u` arrays are destructively overwritten by `dirpreprc_()` — Rust impl should
  store scaling coefficients separately to avoid this confusing pattern
- Volume tolerance check always uses jones=0 regardless of algorithm — potential intentional
  design or bug; Rust impl should match this exactly for faithfulness
- The `s` array (selected rectangles) has a hardcoded limit of MAXDIV=5000 — only relevant
  for DIRECT_ORIGINAL with `dirdoubleinsert_()`


## Iteration 2 — Analysis of DIRsubrout.c Subroutines (2026-02-21)

### What was implemented
- Thoroughly analyzed `nlopt/src/algs/direct/DIRsubrout.c` (1595 lines) function-by-function:
  - `direct_dirgetlevel_()`: Level computation for both algmethod variants. Jones Original
    returns min(length[i]), Gablonsky returns k*n+p encoding both min index and count.
  - `direct_dirchoose_()`: Potentially optimal rectangle selection via pairwise slope-based
    convex hull sweep (not monotone chain). Collects anchor heads per depth, eliminates
    candidates above hull or failing epsilon test. Special handling when no feasible point
    exists (selects only one rect).
  - `direct_dirdoubleinsert_()`: Jones Original only — walks linked lists at each selected
    rect's depth level to find additional rects with f-value within 1e-13 tolerance.
  - `direct_dirgetmaxdeep_()`: Returns min(length[i]) across all dimensions — the "depth"
    of a rectangle (identical to dirgetlevel_ with jones=1).
  - `direct_dirget_i__()`: Finds all dimensions with the minimum length index (longest
    sides). Returns dimension indices and count in arrayi/maxi.
  - `direct_dirsamplepoints_()`: Allocates 2*maxi new rectangle slots from free list,
    copies parent center/lengths, then offsets center coordinates ± delta along each
    divided dimension.
  - `direct_dirdivide_()`: Sorts dimensions by min(f+,f-) using insertion sort
    (dirinsertlist_2__), then trisects in sorted order. Critical detail: dims divided
    first get length incremented in ALL subsequent children.
  - `direct_dirinsertlist_()`: Inserts 2*maxi+1 rectangles (maxi child pairs + parent)
    into depth-indexed anchor lists maintaining f-value sorted order. Handles 6 ordering
    cases for each pair vs existing anchor.
  - `direct_dirreplaceinf_()`: For each infeasible rect, computes bounding box from side
    lengths, searches for nearby feasible points, replaces f-value with min nearby + 1e-6
    perturbation, re-sorts affected lists. Uses isinbox_() helper.
  - `direct_dirinfcn_()`: Unscale x from [0,1]^n to [l,u] via (x+xs2)*xs1, call user
    function, rescale back. Thread-unsafe (modifies x in place).
  - `direct_dirpreprc_()`: Compute scaling: xs1=u-l, xs2=l/(u-l). Validates u>l.
  - `direct_dirheader_()`: Input validation, epsilon sign handling (negative → dynamic
    Jones update), bounds checking, capacity check.
  - `direct_dirinit_()`: Full initialization — precompute thirds[]/levels[], evaluate
    center (0.5,...,0.5), sample 2n neighbors, divide first rectangle, insert into lists.
    Total evals: 2n+1.
  - `direct_dirinitlist_()`: Initialize anchors to 0, f-values to 0, point[] as free
    list chain 1→2→...→MAXFUNC→0, free=1.
  - `direct_dirsummary_()`: Final logging (no algorithmic logic).
- Documented 5 private helper functions: dirinsert_(), dirinsertlist_2__(),
  dirsearchmin_(), isinbox_(), dirresortlist_()
- Created complete function call graph showing all caller/callee relationships

### Files created
- direct-nlopt-rs/analysis/dirsubrout_analysis.md

### Files modified
- plans/prd-direct-nlopt.json (marked second analysis item as passes: true)

### Git commits
- `ac296ab` docs(analysis): analyze DIRsubrout.c subroutines function-by-function

### Test results
- N/A (analysis-only task, no code changes)

### Notes
- The `dirgetlevel_()` `p` variable counts dimensions matching `help` (dim 1's value),
  NOT the minimum `k`. This subtlety is critical for correct Gablonsky level computation.
- `dirinfcn_()` modifies `x` in-place for unscaling/rescaling — the Rust port must use a
  separate scratch buffer for thread safety.
- `dirreplaceinf_()` line 620-621 computes `x[l] = c[l,i]*c1[l] + c[l,i]*c2[l]` which
  appears to be dead code (result stored in x but never used after).
- `dirdoubleinsert_()` uses 1e-13 tolerance for "equal value" — this is hardcoded.
- The `levels[]` array has different structure depending on jones: 2D for jones=0
  (Gablonsky), 1D for jones=1 (Jones Original).


## Iteration 3 — Analysis of DIRserial.c: Serial Function Evaluation (2026-02-21)

### What was implemented
- Thoroughly analyzed `nlopt/src/algs/direct/DIRserial.c` (150 lines) line by line:
  - `direct_dirsamplef_()`: complete function signature with all 26 parameters documented
  - Identified 7 unused parameters in serial version: `logfile`, `free`, `maxfunc`, `maxdeep`,
    `oops`, `delta`, `sample` — these exist for API compatibility with DIRparallel.c
  - Documented f2c 1-based parameter adjustments: `--u`, `--l`, `--x`, `--arrayi`, `--point`,
    `f -= 3` (critical: makes f[(pos<<1)+1]=value, f[(pos<<1)+2]=flag)
  - Documented c__ access pattern: `c__[i + pos * c_dim1]` where c_dim1 = n (row-major, dim-fast)
- Documented the two-pass algorithm structure:
  - **Pass 1** (lines 67–133): Iterate over all 2×maxi new sample points via linked list.
    For each point: copy center to x buffer → call dirinfcn_() (unscale, evaluate, rescale) →
    store result based on kret (0=feasible, ≥1=infeasible, -1=setup error) → update fmax/ifeasiblef/iinfesiblef
  - **Pass 2** (lines 134–149): Re-iterate over same 2×maxi points, update minf/minpos
    considering only feasible points (f[2*pos+2] == 0.0)
- Documented the exact evaluation order from dirsamplepoints_():
  - Chain: start → plus_d1 → minus_d1 → plus_d2 → minus_d2 → ... → plus_dM → minus_dM
  - Positive offset first, then negative, for each of the maxi longest dimensions
- Documented error handling:
  - force_stop: skips evaluation (assigns fmax), overrides kret to -1
  - kret=0: feasible → f_flag=0, update fmax
  - kret≥1: infeasible → f_flag=2, f_value=fmax (uses current accumulated fmax)
  - kret=-1: setup error → f_flag=-1
- Identified independent vs sequential operations for parallelization:
  - **Independent**: All 2×maxi function evaluations (each has own position, coordinates, result slot)
  - **Sequential**: fmax accumulation (used for infeasible replacement), ifeasiblef, iinfesiblef tracking,
    minf/minpos update (Pass 2)
  - **Key subtlety**: Infeasible f-value assignment uses accumulated fmax, so serial vs parallel
    may assign different placeholder values. This is acceptable since dirreplaceinf_() later
    replaces these values anyway.
- Compared with DIRparallel.c (381 lines): PVM-based parallel version with master/slave message
  passing. Not used in NLOPT. Different f-array indexing (column-major vs transposed row-major).
- Outlined Rust port strategy for both serial (exact match) and parallel (rayon par_iter) paths

### Files created
- direct-nlopt-rs/analysis/dirserial_analysis.md

### Files modified
- plans/prd-direct-nlopt.json (marked third analysis item as passes: true)

### Git commits
- `a74dc85` docs(analysis): analyze DIRserial.c serial function evaluation

### Test results
- N/A (analysis-only task, no code changes)

### Notes
- The scratch buffer `x[1..n]` is the only shared mutable state — Rust parallel version must
  allocate per-thread copies (handled naturally by collecting centers into Vec before par_iter)
- The `force_stop` check should use AtomicBool or similar in parallel mode for safe cross-thread access
- For exact serial equivalence (parallel=false), the linked list traversal order must be preserved
- The infeasible fmax assignment order dependence is the only semantic difference between
  serial and parallel — and it doesn't affect final results due to dirreplaceinf_() post-processing


## Iteration 4 — Analysis of hybrid.c: DIRECT + Local Optimization Hybrid (2026-02-21)

### What was implemented
- Thoroughly analyzed `nlopt/src/algs/cdirect/hybrid.c` (345 lines) function-by-function
- Documented the extended hyperrect layout `3n+3`: (diameter, -f, -age, x[n], c[n], w[n])
  - Key difference from cdirect.c: adds `x[n]` local optimum storage between metadata and center
  - f-value and age stored negated so red-black tree max node = largest diameter + best f
- Documented `fcount()`: thin wrapper counting evaluations for local optimizer
- Documented `optimize_rect()`: runs local optimizer within rectangle bounds
  - Computes local bounds from `c ± 0.5*w`
  - Configures local optimizer with remaining eval/time budget
  - Updates stored f-value and global best on success
- Documented `randomize_x()`: sets starting point to random location within middle third of rect
- Documented `longest()`: Gablonsky-style max-side diameter (always used, no Jones option)
- Documented `divide_largest()`: core iteration function
  - Always takes largest rect from tree (no convex hull or epsilon test)
  - Selects ONE dimension to divide (first or random longest), unlike standard DIRECT's all-longest
  - **Bisect vs trisect decision**: if local optimum `x` is far from center `c` (> w/6), bisect; else trisect
  - Bisection shifts center toward optimum, halves width
  - Trisection creates two children at ±w_new offsets
  - Identified potential bug in trisection path: `w[i]` uses loop variable `i∈{-1,+1}` as array index
- Documented `cdirect_hybrid_unscaled()`: main entry point with simple do-while loop
  - Identified potential diameter computation bug: `longest(n, rnew+2*n)` should be `longest(n, rnew+3+2*n)`
- Documented `cdirect_hybrid()`: rescaling wrapper identical to `cdirect()` pattern
- Created comprehensive comparison table: hybrid vs standard DIRECT differences
- Made scope decision: **EXCLUDE hybrid from Rust implementation**
  - Requires local optimizer integration (outside DIRECT library scope)
  - Has suspected bugs in trisection offset and diameter computation
  - Rarely used in practice
  - Architecturally distinct (no PO selection, no convex hull, no epsilon)

### Files created
- direct-nlopt-rs/analysis/hybrid_analysis.md

### Files modified
- plans/prd-direct-nlopt.json (marked hybrid.c analysis as passes: true)

### Git commits
- `86be866` docs(analysis): analyze hybrid.c DIRECT + local optimization hybrid

### Test results
- N/A (analysis-only task, no code changes)

### Notes
- hybrid.c stores f-values and ages NEGATED (r[1]=-f, r[2]=-age) unlike cdirect.c which stores them directly
- The bisect/trisect decision based on local optimum position is the key innovation
- Two potential bugs identified in NLOPT source:
  1. `divide_largest()` line 211: `w[i]` with `i∈{-1,+1}` reads wrong memory for trisection offset
  2. `cdirect_hybrid_unscaled()` line 266: `longest(n, rnew+2*n)` has wrong offset for widths array
- These bugs may be masked by local optimization or rarely-triggered code paths
- The hybrid is the only NLOPT DIRECT variant that uses bisection (all others use trisection exclusively)


## Iteration 2 — Implement types.rs: Core Type Definitions (2026-02-21)

### What was implemented
- Created `src/types.rs` with all core type definitions matching NLOPT's API
- Defined `DirectAlgorithm` enum with 8 variants covering all NLOPT DIRECT algorithms:
  - SGJ cdirect.c variants: Original, LocallyBiased, Randomized + their Unscaled counterparts
  - Gablonsky translation variants: GablonskyOriginal, GablonskyLocallyBiased
- Mapped each variant to NLOPT's internal encoding:
  - `which_alg()` → base-3 encoding for cdirect.c (0, 13, 16)
  - `algmethod()` → 0 (DIRECT_ORIGINAL) or 1 (DIRECT_GABLONSKY) for Gablonsky translation
- Defined `DirectOptions` struct matching NLOPT's `direct_optimize()` parameters:
  - max_feval, max_iter, max_time, magic_eps, magic_eps_abs
  - volume_reltol (default 0.0), sigma_reltol (default -1.0)
  - fglobal (default DIRECT_UNKNOWN_FGLOBAL = -inf), fglobal_reltol (default 0.0)
  - algorithm, parallel
- Defined `DirectResult` struct: x, fun, nfev, nit, success, return_code, message
- Defined type aliases: `Bounds = Vec<(f64, f64)>`, `ObjectiveFn`, `CallbackFn`
- Defined constants: `DIRECT_UNKNOWN_FGLOBAL`, `DIRECT_UNKNOWN_FGLOBAL_RELTOL`
- Implemented `Display` for `DirectReturnCode`, `DirectAlgorithm`, and `DirectResult`
- Implemented `Default` for `DirectOptions` matching NLOPT defaults exactly
- Added 13 unit tests covering type conversions, which_alg decomposition, defaults, Display
- Updated lib.rs to declare the types module and re-export all public types

### Files created
- direct-nlopt-rs/src/types.rs

### Files modified
- direct-nlopt-rs/src/lib.rs (added types module and re-exports)
- plans/prd-direct-nlopt.json (marked types.rs implementation as passes: true)

### Git commits
- `a9f0cf7` feat(types): implement core type definitions matching NLOPT API

### Test results
- 13 tests passed, 0 failed (+13 new tests)
- cargo clippy clean (no warnings)

### Notes
- Default algorithm is LocallyBiased (DIRECT-L), the most commonly used variant
- DIRECT_UNKNOWN_FGLOBAL maps to f64::NEG_INFINITY matching C's -HUGE_VAL
- sigma_reltol defaults to -1.0 (disabled) matching nlopt_get_param(opt, "sigma_reltol", -1.0)
- volume_reltol defaults to 0.0, but NLOPT internally converts <=0 to -1 in direct_wrap.c


## Iteration 3 — Implement storage.rs: SoA Rectangle Storage (2026-02-21)

### What was implemented
- Created `src/storage.rs` implementing `RectangleStorage` struct with SoA layout matching
  NLOPT's Gablonsky Fortran→C translation data structures from DIRect.c and DIRsubrout.c
- `RectangleStorage::new()` — memory allocation matching NLOPT's formulas:
  MAXFUNC = maxf <= 0 ? 101000 : (maxf + 1000 + maxf/2),
  MAXDEEP = maxt <= 0 ? MAXFUNC/5 : (maxt + 1000)
- `init_lists()` — matches `direct_dirinitlist_()`: zeroes anchors[-1..maxdeep],
  chains point[] as free list (1→2→...→maxfunc-1→0), zeroes f_values
- `precompute_thirds()` — computes thirds[k] = 1/3^k for k=0..maxdeep
- `precompute_levels()` — computes levels[] for both jones=0 (Original: w[j]/3^(i-1)
  where w[j]=sqrt(n-j+j/9)*0.5) and jones=1 (Gablonsky: 1/3^k)
- `get_level()` — matches `direct_dirgetlevel_()` exactly:
  jones=1 returns min(lengths), jones=0 returns k*n+p encoding
- `get_max_deep()` — matches `direct_dirgetmaxdeep_()`: returns min of length indices
- `get_longest_dims()` — matches `direct_dirget_i__()`: finds all dimensions with
  minimum length index, returns 1-based indices and count
- `insert_into_list()` — matches `direct_dirinsertlist_()`: inserts maxi pairs of
  child rectangles plus parent into anchor-linked lists sorted by f-value at computed depth
- `insert_sorted()` — matches `dirinsert_()`: sorted insertion helper
- `alloc_rect()` / `free_rect()` — free list allocation/deallocation
- `replace_infeasible()` — matches `direct_dirreplaceinf_()`: scans for infeasible points,
  checks bounding box of each rectangle for nearby feasible points, replaces f-value
  with min nearby feasible + 1e-6 perturbation, or sets to max(fmax+1, f)
- `resort_list()` — matches `dirresortlist_()`: removes and re-inserts rectangle after
  f-value replacement to maintain sorted order
- Helper accessors: f_val(), f_flag(), set_f(), center(), set_center(), length(),
  set_length(), copy_center(), copy_lengths(), remove_from_anchor()
- 21 unit tests covering all functions

### Files created
- direct-nlopt-rs/src/storage.rs

### Files modified
- direct-nlopt-rs/src/lib.rs (added `pub mod storage`)
- plans/prd-direct-nlopt.json (marked storage.rs task as passes: true)

### Git commits
- `a9acb4f` feat(storage): implement SoA rectangle storage with linked-list management

### Test results
- 42 tests passed, 0 failed (+21 new storage tests)
- All clippy warnings resolved

### Notes
- Uses 1-based indexing internally to match NLOPT's Fortran-translated C code
- Index 0 is unused in point/anchor arrays; 0 serves as null sentinel
- anchor array offset: anchor[depth+1] maps to NLOPT's anchor[depth] with -1 → index 0
- replace_infeasible uses xs1/xs2 params (currently prefixed with _ since only used
  in the unscaling step of dirresortlist_ which is delegated to direct.rs)
- The insert_into_list function faithfully reproduces the complex sorting logic from
  DIRsubrout.c including all 6 comparison branches for the pos1/pos2 pair insertion


## Iteration 3 — Implement PotentiallyOptimal Selection (2026-02-21)

### What was implemented
- Implemented `PotentiallyOptimal` struct in storage.rs matching NLOPT's `s` array (MAXDIV × 2)
  with `indices` (rect indices, 1-based) and `rect_levels` (level from get_level())
- Implemented `PotentiallyOptimal::select()` matching `direct_dirchoose_()` in DIRsubrout.c
  lines 102–261 exactly:
  - All-infeasible path: picks first non-empty anchor, returns single selection (lines 134–148)
  - Normal path: collects non-empty anchor heads across depths 0..act_deep (lines 150–159)
  - Infeasible anchor check: anchor[0] in Rust = anchor[-1] in C (lines 162–166)
  - Convex hull elimination sweep: iterates from maxpos down to 1, for each candidate j:
    - Computes minimum slope (helplower) to candidates with larger diameter (lines 178–204)
    - Computes maximum slope (helpgreater) to candidates with smaller diameter (lines 206–231)
    - Eliminates if slope ≤ 0 in either direction (goto L60 equivalent)
    - Eliminates if helpgreater > helplower (above convex hull)
    - Epsilon test: f[j] - K*levels[level_j] > min(minf - eps*|minf|, minf - epsabs)
  - Appends infeasible anchor at the end if present (lines 256–260)
  - Note: NLOPT's `cheat` flag (always 0 in DIRect.c line 140) is documented but skipped
  - Note: In dirchoose_, the `thirds` parameter actually receives the `levels[]` array
    from the caller (DIRect.c line 455) — Rust uses storage.levels directly
- Implemented `PotentiallyOptimal::double_insert()` matching `direct_dirdoubleinsert_()`
  in DIRsubrout.c lines 274–332 exactly:
  - For each selected rect, walks the linked list at the same depth level
  - Adds rects with f-value within 1e-13 of the anchor head (lines 312–328)
  - Returns Err(-6) if selection array capacity exceeded (lines 322–323)
  - Only used with algmethod=0 (DIRECT Original, Jones 1993)
- Added 15 unit tests covering all scenarios from the PRD:
  - Monotonically decreasing f → all selected (convex hull)
  - Rect above hull → excluded
  - Multiple rects at same level → only anchor head considered
  - Epsilon test elimination
  - Gaps in depth distribution
  - All infeasible → picks first available
  - Infeasible anchor appended
  - Jones Original (jones=0) level computation
  - Double insert with equal/different f-values
  - Double insert capacity overflow (Err(-6))
  - Single rect edge case
  - Empty storage edge case
  - Multiple levels with double insert

### Files modified
- direct-nlopt-rs/src/storage.rs (added PotentiallyOptimal struct + select() + double_insert() + 15 tests)
- plans/prd-direct-nlopt.json (marked PotentiallyOptimal task as passes: true)

### Git commits
- `d3f0f86` feat(storage): implement PotentiallyOptimal selection matching dirchoose_

### Test results
- 57 tests passed, 0 failed (+15 new tests)
- cargo clippy clean (0 warnings)

### Notes
- The `cheat`/`kmax` feature in dirchoose_ is always disabled (cheat=0 in DIRect.c:140)
- The clearing loop in C (lines 168–172) has a Fortran translation artifact: loop var j
  but writes to fixed s[k]; in Rust we just clear remaining slots
- The `thirds` parameter in dirchoose_ is confusingly named — it actually receives the
  `levels[]` array from the caller; this is correctly handled in the Rust implementation
- Feasibility check `f_flag <= 1.0` correctly includes both FEASIBLE (0.0) and REPLACED (1.0)
- Level indexing: levels[] is indexed by get_level() return value, which for Gablonsky is
  the min length index (bounded by actual search depth), well within levels[] array bounds
